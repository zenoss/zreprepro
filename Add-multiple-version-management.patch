From e47cd3ff94bb135e28ee4f35f6552fa614e0e4b6 Mon Sep 17 00:00:00 2001
From: Benjamin Drung <benjamin.drung@profitbricks.com>
Date: Tue, 24 Jun 2014 19:27:12 +0200
Subject: [PATCH] Add multiple version management.

The database layout has changed to include the version and the added date
besides the control chunk. This closes Debian bug #570623.
---
 Makefile.am       |   4 +-
 archallflood.c    |  18 +--
 contents.c        |  13 ++-
 copypackages.c    | 137 ++++++++++++++---------
 copypackages.h    |   9 +-
 database.c        | 327 +++++++++++++++++++++++++++++++++++++++++++-----------
 database.h        |  16 ++-
 distribution.c    |  21 ++--
 distribution.h    |   4 +-
 docs/reprepro.1   |  15 ++-
 error.h           |   1 +
 exports.c         |  13 +--
 filelist.c        |   8 +-
 files.c           |  10 +-
 main.c            | 239 +++++++++++++++++++--------------------
 names.c           |  44 ++++++++
 names.h           |   2 +
 needbuild.c       |  10 +-
 packagedata.c     |  82 ++++++++++++++
 packagedata.h     |  61 ++++++++++
 printlistformat.c |  12 +-
 printlistformat.h |   4 +-
 reference.c       |   2 +-
 release.c         |   2 +-
 sizes.c           |   2 +-
 sourcecheck.c     |  16 +--
 target.c          | 317 ++++++++++++++++++++++++++++++++--------------------
 target.h          |  68 ++++++++----
 tracking.c        |  28 ++---
 upgradelist.c     |  24 ++--
 30 files changed, 1041 insertions(+), 468 deletions(-)
 create mode 100644 packagedata.c
 create mode 100644 packagedata.h

diff --git a/Makefile.am b/Makefile.am
index 782524c..5bf3ec8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -18,14 +18,14 @@ AM_CPPFLAGS = $(ARCHIVECPP) $(DBCPPFLAGS)
 reprepro_LDADD = $(ARCHIVELIBS) $(DBLIBS)
 changestool_LDADD = $(ARCHIVELIBS)
 
-reprepro_SOURCES = outhook.c descriptions.c sizes.c sourcecheck.c byhandhook.c archallflood.c needbuild.c globmatch.c printlistformat.c diffindex.c rredpatch.c pool.c atoms.c uncompression.c remoterepository.c indexfile.c copypackages.c sourceextraction.c checksums.c readtextfile.c filecntl.c sha1.c sha256.c configparser.c database.c freespace.c hooks.c log.c changes.c incoming.c uploaderslist.c guesscomponent.c files.c md5.c dirs.c chunks.c reference.c binaries.c sources.c checks.c names.c dpkgversions.c release.c mprintf.c updates.c strlist.c signature_check.c signedfile.c signature.c distribution.c checkindeb.c checkindsc.c checkin.c upgradelist.c target.c aptmethod.c downloadcache.c main.c override.c terms.c termdecide.c ignore.c filterlist.c exports.c tracking.c optionsfile.c donefile.c pull.c contents.c filelist.c $(ARCHIVE_USED) $(ARCHIVE_CONTENTS)
+reprepro_SOURCES = outhook.c descriptions.c sizes.c sourcecheck.c byhandhook.c archallflood.c needbuild.c globmatch.c printlistformat.c diffindex.c rredpatch.c pool.c atoms.c uncompression.c remoterepository.c indexfile.c copypackages.c sourceextraction.c checksums.c readtextfile.c filecntl.c sha1.c sha256.c configparser.c database.c freespace.c hooks.c log.c changes.c incoming.c uploaderslist.c guesscomponent.c files.c md5.c dirs.c chunks.c reference.c binaries.c sources.c checks.c names.c dpkgversions.c release.c mprintf.c updates.c strlist.c signature_check.c signedfile.c signature.c distribution.c checkindeb.c checkindsc.c checkin.c upgradelist.c target.c aptmethod.c downloadcache.c main.c override.c terms.c termdecide.c ignore.c filterlist.c exports.c tracking.c optionsfile.c donefile.c pull.c contents.c filelist.c packagedata.c $(ARCHIVE_USED) $(ARCHIVE_CONTENTS)
 EXTRA_reprepro_SOURCE = $(ARCHIVE_UNUSED)
 
 changestool_SOURCES = uncompression.c sourceextraction.c readtextfile.c filecntl.c tool.c chunkedit.c strlist.c checksums.c sha1.c sha256.c md5.c mprintf.c chunks.c signature.c dirs.c names.c $(ARCHIVE_USED)
 
 rredtool_SOURCES = rredtool.c rredpatch.c mprintf.c filecntl.c sha1.c
 
-noinst_HEADERS = outhook.h descriptions.h sizes.h sourcecheck.h byhandhook.h archallflood.h needbuild.h globmatch.h printlistformat.h pool.h atoms.h uncompression.h remoterepository.h copypackages.h sourceextraction.h checksums.h readtextfile.h filecntl.h sha1.h sha256.h configparser.h database_p.h database.h freespace.h hooks.h log.h changes.h incoming.h guesscomponent.h md5.h dirs.h files.h chunks.h reference.h binaries.h sources.h checks.h names.h release.h error.h mprintf.h updates.h strlist.h signature.h signature_p.h distribution.h debfile.h checkindeb.h checkindsc.h upgradelist.h target.h aptmethod.h downloadcache.h override.h terms.h termdecide.h ignore.h filterlist.h dpkgversions.h checkin.h exports.h globals.h tracking.h trackingt.h optionsfile.h donefile.h pull.h ar.h filelist.h contents.h chunkedit.h uploaderslist.h indexfile.h rredpatch.h diffindex.h
+noinst_HEADERS = outhook.h descriptions.h sizes.h sourcecheck.h byhandhook.h archallflood.h needbuild.h globmatch.h printlistformat.h pool.h atoms.h uncompression.h remoterepository.h copypackages.h sourceextraction.h checksums.h readtextfile.h filecntl.h sha1.h sha256.h configparser.h database_p.h database.h freespace.h hooks.h log.h changes.h incoming.h guesscomponent.h md5.h dirs.h files.h chunks.h reference.h binaries.h sources.h checks.h names.h release.h error.h mprintf.h updates.h strlist.h signature.h signature_p.h distribution.h debfile.h checkindeb.h checkindsc.h upgradelist.h target.h aptmethod.h downloadcache.h override.h terms.h termdecide.h ignore.h filterlist.h dpkgversions.h checkin.h exports.h globals.h tracking.h trackingt.h optionsfile.h donefile.h pull.h ar.h filelist.h contents.h chunkedit.h uploaderslist.h indexfile.h rredpatch.h diffindex.h packagedata.h
 
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in $(srcdir)/configure $(srcdir)/stamp-h.in $(srcdir)/aclocal.m4 $(srcdir)/config.h.in
 
diff --git a/archallflood.c b/archallflood.c
index 5d4d6fe..da9e6ae 100644
--- a/archallflood.c
+++ b/archallflood.c
@@ -327,7 +327,8 @@ static retvalue save_package_version(struct floodlist *list, const char *package
 static retvalue floodlist_initialize(struct floodlist **fl, struct target *t) {
 	struct floodlist *list;
 	retvalue r, r2;
-	const char *packagename, *controlchunk;
+	const char *packagename;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	list = zNEW(struct floodlist);
@@ -343,8 +344,8 @@ static retvalue floodlist_initialize(struct floodlist **fl, struct target *t) {
 		floodlist_free(list);
 		return r;
 	}
-	while (target_nextpackage(&iterator, &packagename, &controlchunk)) {
-		r2 = save_package_version(list, packagename, controlchunk);
+	while (target_nextpackage(&iterator, &packagename, &packagedata)) {
+		r2 = save_package_version(list, packagename, packagedata.chunk);
 		RET_UPDATE(r, r2);
 		if (RET_WAS_ERROR(r2))
 			break;
@@ -570,7 +571,8 @@ static retvalue floodlist_trypackage(struct floodlist *list, const char *package
 
 static retvalue floodlist_pull(struct floodlist *list, struct target *source) {
 	retvalue result, r;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	list->last = NULL;
@@ -578,11 +580,11 @@ static retvalue floodlist_pull(struct floodlist *list, struct target *source) {
 	if (RET_WAS_ERROR(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &package, &control)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		char *version;
 		architecture_t package_architecture;
 
-		r = list->target->getarchitecture(control,
+		r = list->target->getarchitecture(packagedata.chunk,
 				&package_architecture);
 		if (r == RET_NOTHING)
 			continue;
@@ -593,14 +595,14 @@ static retvalue floodlist_pull(struct floodlist *list, struct target *source) {
 		if (package_architecture != architecture_all)
 			continue;
 
-		r = list->target->getversion(control, &version);
+		r = list->target->getversion(packagedata.chunk, &version);
 		if (r == RET_NOTHING)
 			continue;
 		if (!RET_IS_OK(r)) {
 			RET_UPDATE(result, r);
 			break;
 		}
-		r = floodlist_trypackage(list, package, version, control);
+		r = floodlist_trypackage(list, package, version, packagedata.chunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
diff --git a/contents.c b/contents.c
index c1ee77a..192b735 100644
--- a/contents.c
+++ b/contents.c
@@ -160,16 +160,16 @@ retvalue contentsoptions_parse(struct distribution *distribution, struct configi
 	return RET_OK;
 }
 
-static retvalue addpackagetocontents(UNUSED(struct distribution *di), UNUSED(struct target *ta), const char *packagename, const char *chunk, void *data) {
+static retvalue addpackagetocontents(UNUSED(struct distribution *di), UNUSED(struct target *ta), const char *packagename, const struct packagedata *packagedata, void *data) {
 	struct filelist_list *contents = data;
 	retvalue r;
 	char *section, *filekey;
 
-	r = chunk_getvalue(chunk, "Section", &section);
+	r = chunk_getvalue(packagedata->chunk, "Section", &section);
 	/* Ignoring packages without section, as they should not exist anyway */
 	if (!RET_IS_OK(r))
 		return r;
-	r = chunk_getvalue(chunk, "Filename", &filekey);
+	r = chunk_getvalue(packagedata->chunk, "Filename", &filekey);
 	/* dito with filekey */
 	if (!RET_IS_OK(r)) {
 		free(section);
@@ -232,11 +232,12 @@ static retvalue gentargetcontents(struct target *target, struct release *release
 	}
 	result = target_openiterator(target, READONLY, &iterator);
 	if (RET_IS_OK(result)) {
-		const char *package, *control;
+		const char *package;
+		struct packagedata packagedata;
 
-		while (target_nextpackage(&iterator, &package, &control)) {
+		while (target_nextpackage(&iterator, &package, &packagedata)) {
 			r = addpackagetocontents(target->distribution,
-					target, package, control, contents);
+					target, package, &packagedata, contents);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
diff --git a/copypackages.c b/copypackages.c
index 246e5d8..9b210dc 100644
--- a/copypackages.c
+++ b/copypackages.c
@@ -37,6 +37,7 @@
 #include "mprintf.h"
 #include "globmatch.h"
 #include "copypackages.h"
+#include "packagedata.h"
 
 struct target_package_list {
 	struct target_package_list *next;
@@ -58,6 +59,18 @@ struct package_list {
 	/*@null@*/struct target_package_list *targets;
 };
 
+// cascade_strcmp compares the two strings s1 and s2. If the strings are equal, the strings
+// t1 and t2 are compared.
+static int cascade_strcmp(const char *s1, const char *s2, const char *t1, const char *t2) {
+	int result;
+
+	result = strcmp(s1, s2);
+	if (result == 0) {
+		result = strcmp(t1, t2);
+	}
+	return result;
+}
+
 static retvalue list_newpackage(struct package_list *list, struct target *target, const char *sourcename, const char *sourceversion, const char *packagename, const char *packageversion, /*@out@*/struct package **package_p) {
 	struct target_package_list *t, **t_p;
 	struct package *package, **p_p;
@@ -77,12 +90,12 @@ static retvalue list_newpackage(struct package_list *list, struct target *target
 		t = *t_p;
 
 	p_p = &t->packages;
-	while (*p_p != NULL && (c = strcmp(packagename, (*p_p)->name)) < 0)
+	while (*p_p != NULL && (c = cascade_strcmp(packagename, (*p_p)->name, packageversion, (*p_p)->version)) < 0)
 		p_p = &(*p_p)->next;
 	if (*p_p != NULL && c == 0) {
 		// TODO: improve this message..., or some context elsewhere
-		fprintf(stderr, "Multiple occurences of package '%s'!\n",
-				packagename);
+		fprintf(stderr, "Multiple occurences of package '%s' with version '%s'!\n",
+				packagename, packageversion);
 		return RET_ERROR_EXIST;
 	}
 	package = zNEW(struct package);
@@ -366,51 +379,73 @@ struct namelist {
 	bool *found;
 };
 
+static int strcmp2(const char *s1, const char *s2) {
+	if (s1 == NULL || s2 == NULL) {
+		if (s1 == NULL && s2 == NULL) {
+			return 0;
+		} else if (s1 == NULL) {
+			return -1;
+		} else {
+			return 1;
+		}
+	} else {
+		return strcmp(s1, s2);
+	}
+}
+
 static retvalue by_name(struct package_list *list, UNUSED(struct distribution *into), UNUSED(struct distribution *from), struct target *desttarget, struct target *fromtarget, void *data) {
-	struct namelist *d = data;
+	struct nameandversion *nameandversion = data;
+	struct nameandversion *d;
+	struct nameandversion *prev;
 	retvalue result, r;
-	int i, j;
 
 	r = target_initpackagesdb(fromtarget, READONLY);
 	if (RET_WAS_ERROR(r))
 		return r;
 	result = RET_NOTHING;
-	for (i = 0 ; i < d->argc ; i++) {
-		const char *name = d->argv[i];
-		char *chunk;
+	for (d = nameandversion; d->name != NULL ; d++) {
+		struct packagedata packagedata;
 		architecture_t package_architecture;
 
-		for (j = 0 ; j < i ; j++)
-			if (strcmp(d->argv[i], d->argv[j]) == 0)
+		for (prev = nameandversion ; prev < d ; prev++) {
+			if (strcmp(prev->name, d->name) == 0 && strcmp2(prev->version, d->version) == 0)
 				break;
-		if (j < i) {
-			if (verbose >= 0 && ! d->warnedabout[j])
-				fprintf(stderr,
+		}
+		if (prev < d) {
+			if (verbose >= 0 && ! prev->warnedabout) {
+				if (d->version == NULL) {
+					fprintf(stderr,
 "Hint: '%s' was listed multiple times, ignoring all but first!\n",
-						d->argv[i]);
-			d->warnedabout[j] = true;
+							d->name);
+				} else {
+					fprintf(stderr,
+"Hint: '%s=%s' was listed multiple times, ignoring all but first!\n",
+							d->name, d->version);
+				}
+			}
+			prev->warnedabout = true;
 			/* do not complain second is missing if we ignore it: */
-			d->found[i] = true;
+			d->found = true;
 			continue;
 		}
 
-		r = table_getrecord(fromtarget->packages, name, &chunk);
+		r = target_getpackage(fromtarget, d->name, d->version, &packagedata);
 		if (r == RET_NOTHING)
 			continue;
 		RET_ENDUPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
-		r = fromtarget->getarchitecture(chunk, &package_architecture);
+		r = fromtarget->getarchitecture(packagedata.chunk, &package_architecture);
 		RET_ENDUPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
 		r = list_prepareadd(list, desttarget,
-				name, NULL, package_architecture, chunk);
-		free(chunk);
+				d->name, d->version, package_architecture, packagedata.chunk);
+		packagedata_free(&packagedata);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
-		d->found[i] = true;
+		d->found = true;
 	}
 	r = target_closepackagesdb(fromtarget);
 	RET_ENDUPDATE(result, r);
@@ -433,30 +468,24 @@ static void packagelist_done(struct package_list *list) {
 	}
 }
 
-retvalue copy_by_name(struct distribution *into, struct distribution *from, int argc, const char **argv, const struct atomlist *components, const struct atomlist *architectures, const struct atomlist *packagetypes) {
+retvalue copy_by_name(struct distribution *into, struct distribution *from, struct nameandversion *nameandversion, const struct atomlist *components, const struct atomlist *architectures, const struct atomlist *packagetypes) {
 	struct package_list list;
-	struct namelist names = {
-		argc, argv, nzNEW(argc, bool), nzNEW(argc, bool)
-	};
+	struct nameandversion *d;
 	retvalue r;
 
-	if (FAILEDTOALLOC(names.warnedabout) || FAILEDTOALLOC(names.found)) {
-		free(names.found);
-		free(names.warnedabout);
-		return RET_ERROR_OOM;
+	for (d = nameandversion; d->name != NULL; d++) {
+		d->found = false;
+		d->warnedabout = false;
 	}
 
 	memset(&list, 0, sizeof(list));
 	r = copy_by_func(&list, into, from, components,
-			architectures, packagetypes, by_name, &names);
-	free(names.warnedabout);
+			architectures, packagetypes, by_name, nameandversion);
 	if (verbose >= 0 && !RET_WAS_ERROR(r)) {
-		int i;
 		bool first = true;
 
-		assert(names.found != NULL);
-		for (i = 0 ; i < argc ; i++) {
-			if (names.found[i])
+		for (d = nameandversion; d->name != NULL; d++) {
+			if (d->found)
 				continue;
 			if (first)
 				(void)fputs(
@@ -464,14 +493,17 @@ retvalue copy_by_name(struct distribution *into, struct distribution *from, int
 			else
 				(void)fputs(", ", stderr);
 			first = false;
-			(void)fputs(argv[i], stderr);
+			(void)fputs(d->name, stderr);
+			if (d->version != NULL) {
+				(void)fputs("=", stderr);
+				(void)fputs(d->version, stderr);
+			}
 		}
 		if (!first) {
 			(void)fputc('.', stderr);
 			(void)fputc('\n', stderr);
 		}
 	}
-	free(names.found);
 	if (!RET_IS_OK(r))
 		return r;
 	r = packagelist_add(into, &list, from->codename);
@@ -482,7 +514,8 @@ retvalue copy_by_name(struct distribution *into, struct distribution *from, int
 static retvalue by_source(struct package_list *list, UNUSED(struct distribution *into), UNUSED(struct distribution *from), struct target *desttarget, struct target *fromtarget, void *data) {
 	struct namelist *d = data;
 	struct target_cursor iterator;
-	const char *packagename, *chunk;
+	const char *packagename;
+	struct packagedata packagedata;
 	retvalue result, r;
 
 	assert (d->argc > 0);
@@ -492,12 +525,12 @@ static retvalue by_source(struct package_list *list, UNUSED(struct distribution
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &packagename, &chunk)) {
+	while (target_nextpackage(&iterator, &packagename, &packagedata)) {
 		int i;
 		char *source, *sourceversion;
 		architecture_t package_architecture;
 
-		r = fromtarget->getsourceandversion(chunk, packagename,
+		r = fromtarget->getsourceandversion(packagedata.chunk, packagename,
 				&source, &sourceversion);
 		if (r == RET_NOTHING)
 			continue;
@@ -535,13 +568,13 @@ static retvalue by_source(struct package_list *list, UNUSED(struct distribution
 			}
 		}
 		free(source); free(sourceversion);
-		r = fromtarget->getarchitecture(chunk, &package_architecture);
+		r = fromtarget->getarchitecture(packagedata.chunk, &package_architecture);
 		if (RET_WAS_ERROR(r)) {
 			result = r;
 			break;
 		}
 		r = list_prepareadd(list, desttarget,
-				packagename, NULL, package_architecture, chunk);
+				packagename, NULL, package_architecture, packagedata.chunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
@@ -635,7 +668,8 @@ retvalue copy_by_source(struct distribution *into, struct distribution *from, in
 static retvalue by_formula(struct package_list *list, UNUSED(struct distribution *into), UNUSED(struct distribution *from), struct target *desttarget, struct target *fromtarget, void *data) {
 	term *condition = data;
 	struct target_cursor iterator;
-	const char *packagename, *chunk;
+	const char *packagename;
+	struct packagedata packagedata;
 	architecture_t package_architecture;
 	retvalue result, r;
 
@@ -644,21 +678,21 @@ static retvalue by_formula(struct package_list *list, UNUSED(struct distribution
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &packagename, &chunk)) {
-		r = term_decidechunktarget(condition, chunk, desttarget);
+	while (target_nextpackage(&iterator, &packagename, &packagedata)) {
+		r = term_decidechunktarget(condition, packagedata.chunk, desttarget);
 		if (r == RET_NOTHING)
 			continue;
 		if (RET_WAS_ERROR(r)) {
 			result = r;
 			break;
 		}
-		r = fromtarget->getarchitecture(chunk, &package_architecture);
+		r = fromtarget->getarchitecture(packagedata.chunk, &package_architecture);
 		if (RET_WAS_ERROR(r)) {
 			result = r;
 			break;
 		}
 		r = list_prepareadd(list, desttarget,
-				packagename, NULL, package_architecture, chunk);
+				packagename, NULL, package_architecture, packagedata.chunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
@@ -671,7 +705,8 @@ static retvalue by_formula(struct package_list *list, UNUSED(struct distribution
 static retvalue by_glob(struct package_list *list, UNUSED(struct distribution *into), UNUSED(struct distribution *from), struct target *desttarget, struct target *fromtarget, void *data) {
 	const char *glob = data;
 	struct target_cursor iterator;
-	const char *packagename, *chunk;
+	const char *packagename;
+	struct packagedata packagedata;
 	architecture_t package_architecture;
 	retvalue result, r;
 
@@ -680,16 +715,16 @@ static retvalue by_glob(struct package_list *list, UNUSED(struct distribution *i
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &packagename, &chunk)) {
+	while (target_nextpackage(&iterator, &packagename, &packagedata)) {
 		if (!globmatch(packagename, glob))
 			continue;
-		r = fromtarget->getarchitecture(chunk, &package_architecture);
+		r = fromtarget->getarchitecture(packagedata.chunk, &package_architecture);
 		if (RET_WAS_ERROR(r)) {
 			result = r;
 			break;
 		}
 		r = list_prepareadd(list, desttarget,
-				packagename, NULL, package_architecture, chunk);
+				packagename, NULL, package_architecture, packagedata.chunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
diff --git a/copypackages.h b/copypackages.h
index 3515bcd..5768206 100644
--- a/copypackages.h
+++ b/copypackages.h
@@ -5,7 +5,14 @@
 #include "strlist.h"
 #endif
 
-retvalue copy_by_name(struct distribution * /*into*/, struct distribution * /*from*/, int, const char **, const struct atomlist *, const struct atomlist *, const struct atomlist *);
+struct nameandversion {
+	const char *name;
+	const char /*@null@*/ *version;
+	bool warnedabout;
+	bool found;
+};
+
+retvalue copy_by_name(struct distribution * /*into*/, struct distribution * /*from*/, struct nameandversion *, const struct atomlist *, const struct atomlist *, const struct atomlist *);
 retvalue copy_by_source(struct distribution * /*into*/, struct distribution * /*from*/, int, const char **, const struct atomlist *, const struct atomlist *, const struct atomlist *);
 retvalue copy_by_formula(struct distribution * /*into*/, struct distribution * /*from*/, const char *formula, const struct atomlist *, const struct atomlist *, const struct atomlist *);
 retvalue copy_by_glob(struct distribution * /*into*/, struct distribution * /*from*/, const char * /*glob*/, const struct atomlist *, const struct atomlist *, const struct atomlist *);
diff --git a/database.c b/database.c
index 377ede3..d0f2c63 100644
--- a/database.c
+++ b/database.c
@@ -43,6 +43,7 @@
 #include "dpkgversions.h"
 #include "distribution.h"
 #include "database_p.h"
+#include "packagedata.h"
 
 #define STRINGIFY(x) #x
 #define TOSTRING(x) STRINGIFY(x)
@@ -211,16 +212,17 @@ static retvalue database_hasdatabasefile(const char *filename, /*@out@*/bool *ex
 
 enum database_type {
 	dbt_QUERY,
-	dbt_BTREE, dbt_BTREEDUP, dbt_BTREEPAIRS,
+	dbt_BTREE, dbt_BTREEDUP, dbt_BTREEPAIRS, dbt_BTREEVERSIONS,
 	dbt_HASH,
 	dbt_COUNT /* must be last */
 };
 static const uint32_t types[dbt_COUNT] = {
 	DB_UNKNOWN,
-	DB_BTREE, DB_BTREE, DB_BTREE,
+	DB_BTREE, DB_BTREE, DB_BTREE, DB_BTREE,
 	DB_HASH
 };
 
+static int debianversioncompare(UNUSED(DB *db), const DBT *a, const DBT *b);
 #if DB_VERSION_MAJOR >= 6
 static int paireddatacompare(UNUSED(DB *db), const DBT *a, const DBT *b, size_t *locp);
 #else
@@ -242,7 +244,7 @@ static retvalue database_opentable(const char *filename, /*@null@*/const char *s
 		free(fullfilename);
 		return RET_DBERR(dbret);
 	}
-	if (type == dbt_BTREEDUP || type == dbt_BTREEPAIRS) {
+	if (type == dbt_BTREEDUP || type == dbt_BTREEPAIRS || type == dbt_BTREEVERSIONS) {
 		dbret = table->set_flags(table, DB_DUPSORT);
 		if (dbret != 0) {
 			table->err(table, dbret, "db_set_flags(DB_DUPSORT):");
@@ -260,6 +262,15 @@ static retvalue database_opentable(const char *filename, /*@null@*/const char *s
 			return RET_DBERR(dbret);
 		}
 	}
+	if (type == dbt_BTREEVERSIONS) {
+		dbret = table->set_dup_compare(table, debianversioncompare);
+		if (dbret != 0) {
+			table->err(table, dbret, "db_set_dup_compare:");
+			(void)table->close(table, 0);
+			free(fullfilename);
+			return RET_DBERR(dbret);
+		}
+	}
 
 #if DB_VERSION_MAJOR == 5 || DB_VERSION_MAJOR == 6
 #define DB_OPEN(database, filename, name, type, flags) \
@@ -945,33 +956,75 @@ static const char databaseerror[] = "Internal error of the underlying BerkeleyDB
  There is nothing that cannot be solved by another layer of indirection, except
  too many levels of indirection. (Source forgotten) */
 
+struct cursor {
+	DBC *cursor;
+	uint32_t flags;
+	retvalue r;
+};
+
 struct table {
 	char *name, *subname;
 	DB *berkeleydb;
+	DB *sec_berkeleydb;
 	bool *flagreset;
 	bool readonly, verbose;
 };
 
 static void table_printerror(struct table *table, int dbret, const char *action) {
-	if (table->subname != NULL)
-		table->berkeleydb->err(table->berkeleydb, dbret,
-				"%sWithin %s subtable %s at %s",
-				databaseerror, table->name, table->subname,
-				action);
-	else
-		table->berkeleydb->err(table->berkeleydb, dbret,
-				"%sWithin %s at %s",
-				databaseerror, table->name, action);
+	char *error_msg;
+
+	switch (dbret) {
+	case DB_MALFORMED_KEY:
+		error_msg = "DB_MALFORMED_KEY: Primary key does not contain the separator '|'.";
+		break;
+	case RET_ERROR_OOM:
+		error_msg = "RET_ERROR_OOM: Out of memory.";
+		break;
+	default:
+		error_msg = NULL;
+		break;
+	}
+
+	if (error_msg == NULL) {
+		if (table->subname != NULL)
+			table->berkeleydb->err(table->berkeleydb, dbret,
+					"%sWithin %s subtable %s at %s",
+					databaseerror, table->name, table->subname,
+					action);
+		else
+			table->berkeleydb->err(table->berkeleydb, dbret,
+					"%sWithin %s at %s",
+					databaseerror, table->name, action);
+	} else {
+		if (table->subname != NULL)
+			table->berkeleydb->errx(table->berkeleydb,
+					"%sWithin %s subtable %s at %s: %s",
+					databaseerror, table->name, table->subname,
+					action, error_msg);
+		else
+			table->berkeleydb->errx(table->berkeleydb,
+					"%sWithin %s at %s: %s",
+					databaseerror, table->name, action, error_msg);
+	}
 }
 
 retvalue table_close(struct table *table) {
 	int dbret;
-	retvalue result;
+	retvalue result = RET_OK;
 
 	if (table == NULL)
 		return RET_NOTHING;
 	if (table->flagreset != NULL)
 		*table->flagreset = false;
+	if (table->sec_berkeleydb != NULL) {
+		dbret = table->sec_berkeleydb->close(table->sec_berkeleydb, 0);
+		if (dbret != 0) {
+			fprintf(stderr, "db_sec_close(%s, %s): %s\n",
+					table->name, table->subname,
+					db_strerror(dbret));
+			result = RET_DBERR(dbret);
+		}
+	}
 	if (table->berkeleydb == NULL) {
 		assert (table->readonly);
 		dbret = 0;
@@ -982,17 +1035,17 @@ retvalue table_close(struct table *table) {
 				table->name, table->subname,
 				db_strerror(dbret));
 		result = RET_DBERR(dbret);
-	} else
-		result = RET_OK;
+	}
 	free(table->name);
 	free(table->subname);
 	free(table);
 	return result;
 }
 
-retvalue table_getrecord(struct table *table, const char *key, char **data_p) {
+retvalue table_getcomplexrecord(struct table *table, bool secondary, const char *key, /*@out@*/void **data_p, /*@out@*/size_t *len_p) {
 	int dbret;
 	DBT Key, Data;
+	DB *db;
 
 	assert (table != NULL);
 	if (table->berkeleydb == NULL) {
@@ -1004,8 +1057,11 @@ retvalue table_getrecord(struct table *table, const char *key, char **data_p) {
 	CLEARDBT(Data);
 	Data.flags = DB_DBT_MALLOC;
 
-	dbret = table->berkeleydb->get(table->berkeleydb, NULL,
-			&Key, &Data, 0);
+	if (secondary)
+		db = table->sec_berkeleydb;
+	else
+		db = table->berkeleydb;
+	dbret = db->get(db, NULL, &Key, &Data, 0);
 	// TODO: find out what error code means out of memory...
 	if (dbret == DB_NOTFOUND)
 		return RET_NOTHING;
@@ -1015,23 +1071,47 @@ retvalue table_getrecord(struct table *table, const char *key, char **data_p) {
 	}
 	if (FAILEDTOALLOC(Data.data))
 		return RET_ERROR_OOM;
-	if (Data.size <= 0 ||
-	    ((const char*)Data.data)[Data.size-1] != '\0') {
+	if (Data.size <= 0) {
 		if (table->subname != NULL)
 			fprintf(stderr,
-"Database %s(%s) returned corrupted (not null-terminated) data!",
+"Database %s(%s) returned corrupted data!\n",
 					table->name, table->subname);
 		else
 			fprintf(stderr,
-"Database %s returned corrupted (not null-terminated) data!",
+"Database %s returned corrupted data!\n",
 					table->name);
 		free(Data.data);
 		return RET_ERROR;
 	}
 	*data_p = Data.data;
+	*len_p = Data.size;
 	return RET_OK;
 }
 
+retvalue table_getrecord(struct table *table, const char *key, char **data_p) {
+	retvalue result;
+	void *data;
+	size_t len;
+
+	result = table_getcomplexrecord(table, false, key, &data, &len);
+	if (RET_IS_OK(result)) {
+		if (unlikely(((char*)data)[len-1] != '\0')) {
+                if (table->subname != NULL)
+                        fprintf(stderr,
+"Database %s(%s) returned corrupted (not null-terminated) data!\n",
+                                        table->name, table->subname);
+                else
+                        fprintf(stderr,
+"Database %s returned corrupted (not null-terminated) data!\n",
+                                        table->name);
+                free(data);
+                return RET_ERROR;
+		}
+		*data_p = (char*)data;
+	}
+	return result;
+}
+
 retvalue table_getpair(struct table *table, const char *key, const char *value, /*@out@*/const char **data_p, /*@out@*/size_t *datalen_p) {
 	int dbret;
 	DBT Key, Data;
@@ -1218,13 +1298,13 @@ retvalue table_addrecord(struct table *table, const char *key, const char *data,
 	return RET_OK;
 }
 
-retvalue table_adduniqsizedrecord(struct table *table, const char *key, const char *data, size_t data_size, bool allowoverwrite, bool nooverwrite) {
+retvalue table_adduniqsizedrecord(struct table *table, const char *key, const void *data, size_t data_size, bool allowoverwrite, bool nooverwrite) {
 	int dbret;
 	DBT Key, Data;
 
 	assert (table != NULL);
 	assert (!table->readonly && table->berkeleydb != NULL);
-	assert (data_size > 0 && data[data_size-1] == '\0');
+	assert (data_size > 0);
 
 	SETDBT(Key, key);
 	SETDBTl(Data, data, data_size);
@@ -1249,7 +1329,7 @@ retvalue table_adduniqsizedrecord(struct table *table, const char *key, const ch
 	return RET_OK;
 }
 retvalue table_adduniqrecord(struct table *table, const char *key, const char *data) {
-	return table_adduniqsizedrecord(table, key, data, strlen(data)+1,
+	return table_adduniqsizedstring(table, key, data, strlen(data)+1,
 			false, false);
 }
 
@@ -1282,26 +1362,26 @@ retvalue table_deleterecord(struct table *table, const char *key, bool ignoremis
 	return RET_OK;
 }
 
-retvalue table_replacerecord(struct table *table, const char *key, const char *data) {
+retvalue table_replacesizedrecord(struct table *table, const char *key, const void *data, size_t data_size) {
 	retvalue r;
 
 	r = table_deleterecord(table, key, false);
 	if (r != RET_ERROR_MISSING && RET_WAS_ERROR(r))
 		return r;
-	return table_adduniqrecord(table, key, data);
+	return table_adduniqsizedrecord(table, key, data, data_size, false, false);
 }
 
-struct cursor {
-	DBC *cursor;
-	uint32_t flags;
-	retvalue r;
-};
-
 retvalue table_newglobalcursor(struct table *table, struct cursor **cursor_p) {
+	DB *berkeleydb;
 	struct cursor *cursor;
 	int dbret;
 
-	if (table->berkeleydb == NULL) {
+	berkeleydb = table->berkeleydb;
+	if (table->sec_berkeleydb != NULL) {
+		berkeleydb = table->sec_berkeleydb;
+	}
+
+	if (berkeleydb == NULL) {
 		assert (table->readonly);
 		*cursor_p = NULL;
 		return RET_OK;
@@ -1314,7 +1394,7 @@ retvalue table_newglobalcursor(struct table *table, struct cursor **cursor_p) {
 	cursor->cursor = NULL;
 	cursor->flags = DB_NEXT;
 	cursor->r = RET_OK;
-	dbret = table->berkeleydb->cursor(table->berkeleydb, NULL,
+	dbret = berkeleydb->cursor(berkeleydb, NULL,
 			&cursor->cursor, 0);
 	if (dbret != 0) {
 		table_printerror(table, dbret, "cursor");
@@ -1325,12 +1405,23 @@ retvalue table_newglobalcursor(struct table *table, struct cursor **cursor_p) {
 	return RET_OK;
 }
 
-static inline retvalue parse_pair(struct table *table, DBT Key, DBT Data, /*@null@*//*@out@*/const char **key_p, /*@out@*/const char **value_p, /*@out@*/const char **data_p, /*@out@*/size_t *datalen_p) {
+static inline retvalue parse_pair(struct table *table, const void *key, size_t key_size, const void *data, size_t data_size, /*@null@*//*@out@*/const char **key_p, /*@out@*/const char **value_p, /*@out@*/const char **data_p, /*@out@*/size_t *datalen_p) {
 	/*@dependant@*/ const char *separator;
 
-	if (Key.size == 0 || Data.size == 0 ||
-	    ((const char*)Key.data)[Key.size-1] != '\0' ||
-	    ((const char*)Data.data)[Data.size-1] != '\0') {
+	if (key != NULL && (key_size == 0 || ((const char*)key)[key_size-1] != '\0')) {
+		if (table->subname != NULL)
+			fprintf(stderr,
+"Database %s(%s) returned corrupted (not null-terminated) key!",
+					table->name, table->subname);
+		else
+			fprintf(stderr,
+"Database %s returned corrupted (not null-terminated) key!",
+					table->name);
+		return RET_ERROR;
+	}
+
+	if (data_size == 0 ||
+	    ((const char*)data)[data_size-1] != '\0') {
 		if (table->subname != NULL)
 			fprintf(stderr,
 "Database %s(%s) returned corrupted (not null-terminated) data!",
@@ -1341,7 +1432,7 @@ static inline retvalue parse_pair(struct table *table, DBT Key, DBT Data, /*@nul
 					table->name);
 		return RET_ERROR;
 	}
-	separator = memchr(Data.data, '\0', Data.size-1);
+	separator = memchr(data, '\0', data_size-1);
 	if (separator == NULL) {
 		if (table->subname != NULL)
 			fprintf(stderr,
@@ -1354,20 +1445,25 @@ static inline retvalue parse_pair(struct table *table, DBT Key, DBT Data, /*@nul
 		return RET_ERROR;
 	}
 	if (key_p != NULL)
-		*key_p = Key.data;
-	*value_p = Data.data;
+		*key_p = key;
+	*value_p = data;
 	*data_p = separator + 1;
-	*datalen_p = Data.size - (separator - (const char*)Data.data) - 2;
+	*datalen_p = data_size - (separator - (const char*)data) - 2;
 	return RET_OK;
 }
 
-retvalue table_newduplicatecursor(struct table *table, const char *key, struct cursor **cursor_p, const char **value_p, const char **data_p, size_t *datalen_p) {
+retvalue table_newduplicatecursor(struct table *table, bool secondary, const char *key, struct cursor **cursor_p, const void **data_p, size_t *datalen_p) {
 	struct cursor *cursor;
 	int dbret;
 	DBT Key, Data;
-	retvalue r;
+	DB *berkeleydb;
 
-	if (table->berkeleydb == NULL) {
+	berkeleydb = table->berkeleydb;
+	if (secondary && table->sec_berkeleydb != NULL) {
+		berkeleydb = table->sec_berkeleydb;
+	}
+
+	if (berkeleydb == NULL) {
 		assert (table->readonly);
 		*cursor_p = NULL;
 		return RET_NOTHING;
@@ -1380,7 +1476,7 @@ retvalue table_newduplicatecursor(struct table *table, const char *key, struct c
 	cursor->cursor = NULL;
 	cursor->flags = DB_NEXT_DUP;
 	cursor->r = RET_OK;
-	dbret = table->berkeleydb->cursor(table->berkeleydb, NULL,
+	dbret = berkeleydb->cursor(berkeleydb, NULL,
 			&cursor->cursor, 0);
 	if (dbret != 0) {
 		table_printerror(table, dbret, "cursor");
@@ -1401,18 +1497,47 @@ retvalue table_newduplicatecursor(struct table *table, const char *key, struct c
 		free(cursor);
 		return RET_DBERR(dbret);
 	}
-	r = parse_pair(table, Key, Data, NULL, value_p, data_p, datalen_p);
-	assert (r != RET_NOTHING);
-	if (RET_WAS_ERROR(r)) {
+
+	if (Key.size == 0 || ((const char*)Key.data)[Key.size-1] != '\0') {
+		if (table->subname != NULL)
+			fprintf(stderr,
+"Database %s(%s) returned corrupted (not null-terminated) key!",
+					table->name, table->subname);
+		else
+			fprintf(stderr,
+"Database %s returned corrupted (not null-terminated) key!",
+					table->name);
 		(void)cursor->cursor->c_close(cursor->cursor);
 		free(cursor);
-		return r;
+		return RET_ERROR;
 	}
 
 	*cursor_p = cursor;
+	*data_p = Data.data;
+	*datalen_p = Data.size;
 	return RET_OK;
 }
 
+inline retvalue table_newduplicatepairedcursor(struct table *table, const char *key, struct cursor **cursor_p, const char **value_p, const char **data_p, size_t *datalen_p) {
+	retvalue r;
+	struct cursor *cursor;
+	const void *data;
+	size_t datalen;
+
+	r = table_newduplicatecursor(table, false, key, &cursor, &data, &datalen);
+
+	if (RET_IS_OK(r)) {
+		r = parse_pair(table, NULL, 0, data, datalen, NULL, value_p, data_p, datalen_p);
+		assert (r != RET_NOTHING);
+		if (RET_WAS_ERROR(r)) {
+			(void)cursor->cursor->c_close(cursor->cursor);
+			free(cursor);
+		}
+	}
+
+	return r;
+}
+
 retvalue table_newpairedcursor(struct table *table, const char *key, const char *value, struct cursor **cursor_p, const char **data_p, size_t *datalen_p) {
 	struct cursor *cursor;
 	int dbret;
@@ -1532,7 +1657,32 @@ bool cursor_nexttemp(struct table *table, struct cursor *cursor, const char **ke
 	return true;
 }
 
-bool cursor_nexttempdata(struct table *table, struct cursor *cursor, const char **key, const char **data, size_t *len_p) {
+bool cursor_nexttempstring(struct table *table, struct cursor *cursor, const char **key, const char **data_p, size_t *len_p) {
+	bool success;
+	void *data;
+	size_t len;
+
+	success = cursor_nexttempdata(table, cursor, key, &data, &len);
+	if (success) {
+		if (len <= 0 || ((const char*)data)[len-1] != '\0') {
+			if (table->subname != NULL)
+				fprintf(stderr,
+	"Database %s(%s) returned corrupted (not null-terminated) data!\n",
+						table->name, table->subname);
+			else
+				fprintf(stderr,
+	"Database %s returned corrupted (not null-terminated) data!\n",
+						table->name);
+			cursor->r = RET_ERROR;
+			return false;
+		}
+		*data_p = data;
+		*len_p = len - 1;
+	}
+	return success;
+}
+
+bool cursor_nexttempdata(struct table *table, struct cursor *cursor, const char **key, void **data, size_t *len_p) {
 	DBT Key, Data;
 	int dbret;
 
@@ -1542,7 +1692,7 @@ bool cursor_nexttempdata(struct table *table, struct cursor *cursor, const char
 	CLEARDBT(Key);
 	CLEARDBT(Data);
 
-	dbret = cursor->cursor->c_get(cursor->cursor, &Key, &Data, DB_NEXT);
+	dbret = cursor->cursor->c_get(cursor->cursor, &Key, &Data, cursor->flags);
 	if (dbret == DB_NOTFOUND)
 		return false;
 
@@ -1552,15 +1702,14 @@ bool cursor_nexttempdata(struct table *table, struct cursor *cursor, const char
 		return false;
 	}
 	if (Key.size <= 0 || Data.size <= 0 ||
-	    ((const char*)Key.data)[Key.size-1] != '\0' ||
-	    ((const char*)Data.data)[Data.size-1] != '\0') {
+	    ((const char*)Key.data)[Key.size-1] != '\0') {
 		if (table->subname != NULL)
 			fprintf(stderr,
-"Database %s(%s) returned corrupted (not null-terminated) data!",
+"Database %s(%s) returned corrupted (not null-terminated) key!\n",
 					table->name, table->subname);
 		else
 			fprintf(stderr,
-"Database %s returned corrupted (not null-terminated) data!",
+"Database %s returned corrupted (not null-terminated) key!\n",
 					table->name);
 		cursor->r = RET_ERROR;
 		return false;
@@ -1568,7 +1717,7 @@ bool cursor_nexttempdata(struct table *table, struct cursor *cursor, const char
 	if (key != NULL)
 		*key = Key.data;
 	*data = Data.data;
-	*len_p = Data.size - 1;
+	*len_p = Data.size;
 	return true;
 }
 
@@ -1598,7 +1747,7 @@ bool cursor_nextpair(struct table *table, struct cursor *cursor, /*@null@*/const
 		cursor->r = RET_DBERR(dbret);
 		return false;
 	}
-	r = parse_pair(table, Key, Data, key_p, value_p, data_p, datalen_p);
+	r = parse_pair(table, Key.data, Key.size, Data.data, Data.size, key_p, value_p, data_p, datalen_p);
 	if (RET_WAS_ERROR(r)) {
 		cursor->r = r;
 		return false;
@@ -1754,6 +1903,24 @@ retvalue database_openreferences(void) {
 	return RET_OK;
 }
 
+static int debianversioncompare(UNUSED(DB *db), const DBT *a, const DBT *b) {
+	const char *a_version;
+	const char *b_version;
+	int versioncmp;
+	retvalue r;
+
+	// TODO: Check lenght of a->data and b->data
+	a_version = packagedata_getversion(a->data);
+	b_version = packagedata_getversion(b->data);
+	r = dpkgversions_cmp(a_version, b_version, &versioncmp);
+	if (RET_WAS_ERROR(r)) {
+		fprintf(stderr, "Parse errors processing versions.\n");
+		return r;
+	}
+
+	return -versioncmp;
+}
+
 /* only compare the first 0-terminated part of the data */
 static int paireddatacompare(UNUSED(DB *db), const DBT *a, const DBT *b
 #if DB_VERSION_MAJOR >= 6
@@ -1797,8 +1964,28 @@ retvalue database_opentracking(const char *codename, bool readonly, struct table
 	return RET_OK;
 }
 
+static int get_package_name(DB *secondary, const DBT *pkey, const DBT *pdata, DBT *skey) {
+	const char *separator;
+	size_t length;
+
+	separator = memchr(pkey->data, '|', pkey->size);
+	if (unlikely(separator == NULL)) {
+		return DB_MALFORMED_KEY;
+	}
+
+	length = (size_t)separator - (size_t)pkey->data;
+	skey->flags = DB_DBT_APPMALLOC;
+	skey->data = strndup(pkey->data, length);
+	if (FAILEDTOALLOC(skey->data)) {
+		return RET_ERROR_OOM;
+	}
+	skey->size = length + 1;
+	return 0;
+}
+
 retvalue database_openpackages(const char *identifier, bool readonly, struct table **table_p) {
 	struct table *table;
+	struct table *secondary_table;
 	retvalue r;
 
 	if (rdb_nopackages) {
@@ -1820,6 +2007,22 @@ retvalue database_openpackages(const char *identifier, bool readonly, struct tab
 	assert (r != RET_NOTHING);
 	if (RET_WAS_ERROR(r))
 		return r;
+
+	r = database_table("packages.secondary.db", identifier,
+			dbt_BTREEVERSIONS, readonly?DB_RDONLY:DB_CREATE, &secondary_table);
+	assert (r != RET_NOTHING);
+	if (RET_WAS_ERROR(r))
+		return r;
+
+	if (table->berkeleydb != NULL) {
+		r = table->berkeleydb->associate(table->berkeleydb, NULL,
+				secondary_table->berkeleydb, get_package_name, 0);
+		if (RET_WAS_ERROR(r)) {
+			return r;
+		}
+	}
+
+	table->sec_berkeleydb = secondary_table->berkeleydb;
 	table->flagreset = &rdb_packagesdatabaseopen;
 	rdb_packagesdatabaseopen = true;
 	*table_p = table;
@@ -1957,9 +2160,9 @@ static retvalue table_copy(struct table *oldtable, struct table *newtable) {
 	r = table_newglobalcursor(oldtable, &cursor);
 	if (!RET_IS_OK(r))
 		return r;
-	while (cursor_nexttempdata(oldtable, cursor, &filekey,
+	while (cursor_nexttempstring(oldtable, cursor, &filekey,
 				&data, &data_len)) {
-		r = table_adduniqsizedrecord(newtable, filekey,
+		r = table_adduniqsizedstring(newtable, filekey,
 				data, data_len+1, false, true);
 		if (RET_WAS_ERROR(r))
 			return r;
@@ -2127,7 +2330,7 @@ static inline retvalue translate(struct table *oldmd5sums, struct table *newchec
 			return r;
 		}
 		numold++;
-		r = table_adduniqsizedrecord(newchecksums, filekey,
+		r = table_adduniqsizedstring(newchecksums, filekey,
 				combined, combinedlen + 1, true, false);
 		assert (r != RET_NOTHING);
 		if (!RET_IS_OK(r)) {
diff --git a/database.h b/database.h
index 7791d09..d38ffec 100644
--- a/database.h
+++ b/database.h
@@ -36,25 +36,33 @@ bool table_isempty(struct table *);
 bool table_recordexists(struct table *, const char *);
 /* retrieve a record from the database, return RET_NOTHING if there is none: */
 retvalue table_getrecord(struct table *, const char *, /*@out@*/char **);
+retvalue table_getcomplexrecord(struct table *, bool secondary, const char *key, /*@out@*/void **data_p, /*@out@*/size_t *len_p);
 retvalue table_gettemprecord(struct table *, const char *, /*@out@*//*@null@*/const char **, /*@out@*//*@null@*/size_t *);
 retvalue table_getpair(struct table *, const char *, const char *, /*@out@*/const char **, /*@out@*/size_t *);
 
-retvalue table_adduniqsizedrecord(struct table *, const char * /*key*/, const char * /*data*/, size_t /*data_size*/, bool /*allowoverwrote*/, bool /*nooverwrite*/);
+retvalue table_adduniqsizedrecord(struct table *, const char * /*key*/, const void * /*data*/, size_t /*data_size*/, bool /*allowoverwrite*/, bool /*nooverwrite*/);
 retvalue table_adduniqrecord(struct table *, const char * /*key*/, const char * /*data*/);
 retvalue table_addrecord(struct table *, const char * /*key*/, const char * /*data*/, size_t /*len*/, bool /*ignoredups*/);
-retvalue table_replacerecord(struct table *, const char *key, const char *data);
+retvalue table_replacesizedrecord(struct table *, const char *key, const void *data, size_t data_size);
 retvalue table_deleterecord(struct table *, const char *key, bool ignoremissing);
 retvalue table_checkrecord(struct table *, const char *key, const char *data);
 retvalue table_removerecord(struct table *, const char *key, const char *data);
 
 retvalue table_newglobalcursor(struct table *, /*@out@*/struct cursor **);
-retvalue table_newduplicatecursor(struct table *, const char *, /*@out@*/struct cursor **, /*@out@*/const char **, /*@out@*/const char **, /*@out@*/size_t *);
+retvalue table_newduplicatecursor(struct table *, bool secondary, const char *, /*@out@*/struct cursor **, /*@out@*/const void **, /*@out@*/size_t *);
+retvalue table_newduplicatepairedcursor(struct table *table, const char *key, struct cursor **cursor_p, const char **value_p, const char **data_p, size_t *datalen_p);
 retvalue table_newpairedcursor(struct table *, const char *, const char *, /*@out@*/struct cursor **, /*@out@*//*@null@*/const char **, /*@out@*//*@null@*/size_t *);
 bool cursor_nexttemp(struct table *, struct cursor *, /*@out@*/const char **, /*@out@*/const char **);
-bool cursor_nexttempdata(struct table *, struct cursor *, /*@out@*/const char **, /*@out@*/const char **, /*@out@*/size_t *);
+bool cursor_nexttempdata(struct table *, struct cursor *, /*@out@*/const char **key, /*@out@*/void **data, /*@out@*/size_t *len_p);
+bool cursor_nexttempstring(struct table *, struct cursor *, /*@out@*/const char **, /*@out@*/const char **, /*@out@*/size_t *);
 bool cursor_nextpair(struct table *, struct cursor *, /*@null@*//*@out@*/const char **, /*@out@*/const char **, /*@out@*/const char **, /*@out@*/size_t *);
 retvalue cursor_replace(struct table *, struct cursor *, const char *, size_t);
 retvalue cursor_delete(struct table *, struct cursor *, const char *, /*@null@*/const char *);
 retvalue cursor_close(struct table *, /*@only@*/struct cursor *);
 
+static inline retvalue table_adduniqsizedstring(struct table *table, const char *key, const char *data, size_t data_size, bool allowoverwrite, bool nooverwrite) {
+	assert (data_size > 0 && data[data_size-1] == '\0');
+	return table_adduniqsizedrecord(table, key, data, data_size, allowoverwrite, nooverwrite);
+}
+
 #endif
diff --git a/distribution.c b/distribution.c
index 6db17da..9b8cd66 100644
--- a/distribution.c
+++ b/distribution.c
@@ -518,7 +518,8 @@ retvalue distribution_foreach_package(struct distribution *distribution, const s
 	retvalue result, r;
 	struct target *t;
 	struct target_cursor iterator;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 
 	result = RET_NOTHING;
 	for (t = distribution->targets ; t != NULL ; t = t->next) {
@@ -535,8 +536,8 @@ retvalue distribution_foreach_package(struct distribution *distribution, const s
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			return result;
-		while (target_nextpackage(&iterator, &package, &control)) {
-			r = action(distribution, t, package, control, data);
+		while (target_nextpackage(&iterator, &package, &packagedata)) {
+			r = action(distribution, t, package, &packagedata, data);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
@@ -552,7 +553,8 @@ retvalue distribution_foreach_package(struct distribution *distribution, const s
 retvalue distribution_foreach_package_c(struct distribution *distribution, const struct atomlist *components, architecture_t architecture, packagetype_t packagetype, each_package_action action, void *data) {
 	retvalue result, r;
 	struct target *t;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	result = RET_NOTHING;
@@ -568,8 +570,8 @@ retvalue distribution_foreach_package_c(struct distribution *distribution, const
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			return result;
-		while (target_nextpackage(&iterator, &package, &control)) {
-			r = action(distribution, t, package, control, data);
+		while (target_nextpackage(&iterator, &package, &packagedata)) {
+			r = action(distribution, t, package, &packagedata, data);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
@@ -1083,7 +1085,8 @@ retvalue distribution_remove_packages(struct distribution *distribution, const s
 	retvalue result, r;
 	struct target *t;
 	struct target_cursor iterator;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 
 	if (distribution->readonly) {
 		fprintf(stderr,
@@ -1100,9 +1103,9 @@ retvalue distribution_remove_packages(struct distribution *distribution, const s
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			return result;
-		while (target_nextpackage(&iterator, &package, &control)) {
+		while (target_nextpackage(&iterator, &package, &packagedata)) {
 			r = decider(distribution, t,
-					package, control, data);
+					package, &packagedata, data);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
diff --git a/distribution.h b/distribution.h
index 80c7bb8..e695287 100644
--- a/distribution.h
+++ b/distribution.h
@@ -22,6 +22,8 @@ struct distribution;
 #ifndef REPREPRO_CONTENTS_H
 #include "contents.h"
 #endif
+#include "packagedata.h"
+
 struct overridefile;
 struct uploaders;
 
@@ -116,7 +118,7 @@ retvalue distribution_get(struct distribution * /*all*/, const char *, bool /*lo
 retvalue distribution_prepareforwriting(struct distribution *);
 
 typedef retvalue each_target_action(struct distribution *, struct target *, void *);
-typedef retvalue each_package_action(struct distribution *, struct target *, const char *, const char *, void *);
+typedef retvalue each_package_action(struct distribution *, struct target *, const char *, const struct packagedata *, void *);
 
 /* call <action> for each package of <distribution> */
 retvalue distribution_foreach_package(struct distribution *, /*@null@*/const struct atomlist *, /*@null@*/const struct atomlist *, /*@null@*/const struct atomlist *, each_package_action, /*@null@*/each_target_action, void *);
diff --git a/docs/reprepro.1 b/docs/reprepro.1
index d017c0f..0520c36 100644
--- a/docs/reprepro.1
+++ b/docs/reprepro.1
@@ -660,11 +660,12 @@ List the versions of the the specified package in all distributions.
 .B lsbycomponent \fIpackage-name\fP
 Like ls, but group by component (and print component names).
 .TP
-.B remove \fIcodename\fP \fIpackage-names\fP
-Delete all packages in the specified distribution,
+.B remove \fIcodename\fP \fIpackage-names\fP\fR[\fP=\fIversion\fP\fR]\fP \fI...\fP
+Delete packages in the specified distribution,
 that have package name listed as argument.
-(i.e. remove all packages \fBlist\fP with the same arguments and options
-would list, except that an empty package list is not allowed.)
+Package versions must be specified by appending '\fB=\fP' and the
+version to the name (without spaces). When no version is specified, the latest
+package version is removed.
 
 Note that like any other operation removing or replacing a package,
 the old package's files are unreferenced and thus may be automatically
@@ -880,11 +881,13 @@ used files.
 Check all source package tracking information for the given distributions
 for files no longer to keep.
 .TP
-.B copy \fIdestination-codename\fP \fIsource-codename\fP \fIpackages...\fP
+.B copy \fIdestination-codename\fP \fIsource-codename\fP \fIpackage\fP\fR[\fP=\fIversion\fP\fR]\fP \fI...\fP
 Copy the given packages from one distribution to another.
 The packages are copied verbatim, no override files are consulted.
 Only components and architectures present in the source distribution are
-copied.
+copied. Package versions must be specified by appending '\fB=\fP' and the
+version to the name (without spaces). When no version is specified, the latest
+package version is copied.
 .TP
 .B copysrc \fIdestination-codename\fP \fIsource-codename\fP \fIsource-package\fP \fR[\fP\fIversions\fP\fR]\fP
 look at each package
diff --git a/error.h b/error.h
index 0d5a46d..715b1a8 100644
--- a/error.h
+++ b/error.h
@@ -10,6 +10,7 @@ bool interrupted(void);
 /* retvalue is simply an int.
  * just named to show it follows the given semantics */
 /*@numabstract@*/ enum retvalue_enum {
+	DB_MALFORMED_KEY = -30001,
 	RET_ERROR_INCOMING_DENY = -13,
 	RET_ERROR_INTERNAL = -12,
 	RET_ERROR_BZ2 = -11,
diff --git a/exports.c b/exports.c
index 9dd6812..4ce8221 100644
--- a/exports.c
+++ b/exports.c
@@ -459,8 +459,8 @@ retvalue export_target(const char *relativedir, struct target *target,  const st
 	const char *status;
 	char *relfilename;
 	char buffer[100];
-	const char *chunk;
-	size_t chunk_len;
+	const char *packagename;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	relfilename = calc_dirconcat(relativedir, exportmode->filename);
@@ -493,13 +493,12 @@ retvalue export_target(const char *relativedir, struct target *target,  const st
 			free(relfilename);
 			return r;
 		}
-		while (target_nextpackage_len(&iterator, NULL,
-					&chunk, &chunk_len)) {
-			if (chunk_len == 0)
+		while (target_nextpackage(&iterator, &packagename, &packagedata)) {
+			if (packagedata.fields_len->chunk_len == 0)
 				continue;
-			(void)release_writedata(file, chunk, chunk_len);
+			(void)release_writedata(file, packagedata.chunk, packagedata.fields_len->chunk_len-1);
 			(void)release_writestring(file, "\n");
-			if (chunk[chunk_len-1] != '\n')
+			if (packagedata.chunk[packagedata.fields_len->chunk_len-2] != '\n')
 				(void)release_writestring(file, "\n");
 		}
 		r = target_closeiterator(&iterator);
diff --git a/filelist.c b/filelist.c
index 96b48c9..2507401 100644
--- a/filelist.c
+++ b/filelist.c
@@ -454,7 +454,7 @@ retvalue filelist_addpackage(struct filelist_list *list, const char *packagename
 	if (RET_IS_OK(r)) {
 		r = filelist_addfiles(list, package, filekey, c, len + 1);
 		if (contents != NULL)
-			r = table_adduniqsizedrecord(rdb_contents, filekey,
+			r = table_adduniqsizedstring(rdb_contents, filekey,
 					contents, len + 1, true, false);
 	}
 	free(contents);
@@ -462,7 +462,7 @@ retvalue filelist_addpackage(struct filelist_list *list, const char *packagename
 }
 
 retvalue fakefilelist(const char *filekey) {
-	return table_adduniqsizedrecord(rdb_contents, filekey,
+	return table_adduniqsizedstring(rdb_contents, filekey,
 			"", 1, true, false);
 }
 
@@ -676,7 +676,7 @@ retvalue filelists_translate(struct table *oldtable, struct table *newtable) {
 	r = table_newglobalcursor(oldtable, &cursor);
 	if (!RET_IS_OK(r))
 		return r;
-	while (cursor_nexttempdata(oldtable, cursor, &filekey,
+	while (cursor_nexttempstring(oldtable, cursor, &filekey,
 				&olddata, &olddata_len)) {
 		const char *p;
 		size_t l;
@@ -697,7 +697,7 @@ retvalue filelists_translate(struct table *oldtable, struct table *newtable) {
 		r = filelistcompressor_finish(&c, &newdata, &newdata_size);
 		if (!RET_IS_OK(r))
 			break;
-		r = table_adduniqsizedrecord(newtable, filekey,
+		r = table_adduniqsizedstring(newtable, filekey,
 				newdata, newdata_size, false, false);
 		free(newdata);
 		if (RET_WAS_ERROR(r))
diff --git a/files.c b/files.c
index 0d2174f..668e433 100644
--- a/files.c
+++ b/files.c
@@ -59,7 +59,7 @@ retvalue files_add_checksums(const char *filekey, const struct checksums *checks
 	r = checksums_getcombined(checksums, &combined, &combinedlen);
 	if (!RET_IS_OK(r))
 		return r;
-	r = table_adduniqsizedrecord(rdb_checksums, filekey,
+	r = table_adduniqsizedstring(rdb_checksums, filekey,
 			combined, combinedlen + 1, true, false);
 	if (!RET_IS_OK(r))
 		return r;
@@ -75,7 +75,7 @@ static retvalue files_replace_checksums(const char *filekey, const struct checks
 	r = checksums_getcombined(checksums, &combined, &combinedlen);
 	if (!RET_IS_OK(r))
 		return r;
-	return table_adduniqsizedrecord(rdb_checksums, filekey,
+	return table_adduniqsizedstring(rdb_checksums, filekey,
 			combined, combinedlen + 1, true, false);
 }
 
@@ -378,7 +378,7 @@ retvalue files_checkpool(bool fast) {
 	r = table_newglobalcursor(rdb_checksums, &cursor);
 	if (!RET_IS_OK(r))
 		return r;
-	while (cursor_nexttempdata(rdb_checksums, cursor,
+	while (cursor_nexttempstring(rdb_checksums, cursor,
 				&filekey, &combined, &combinedlen)) {
 		r = checksums_setall(&expected, combined, combinedlen);
 		if (RET_WAS_ERROR(r)) {
@@ -424,7 +424,7 @@ retvalue files_collectnewchecksums(void) {
 	r = table_newglobalcursor(rdb_checksums, &cursor);
 	if (!RET_IS_OK(r))
 		return r;
-	while (cursor_nexttempdata(rdb_checksums, cursor,
+	while (cursor_nexttempstring(rdb_checksums, cursor,
 				&filekey, &all, &alllen)) {
 		r = checksums_setall(&expected, all, alllen);
 		if (!RET_IS_OK(r)) {
@@ -520,7 +520,7 @@ static retvalue regenerate_filelist(void *data, const char *filekey) {
 				p += strlen(p)+1;
 			}
 		}
-		r = table_adduniqsizedrecord(rdb_contents,
+		r = table_adduniqsizedstring(rdb_contents,
 				filekey, filelist, fls, true, true);
 		free(filelist);
 	}
diff --git a/main.c b/main.c
index 37f1d3b..bed7dd8 100644
--- a/main.c
+++ b/main.c
@@ -74,6 +74,7 @@
 #include "filterlist.h"
 #include "descriptions.h"
 #include "outhook.h"
+#include "packagedata.h"
 
 #ifndef STD_BASE_DIR
 #define STD_BASE_DIR "."
@@ -645,19 +646,19 @@ ACTION_R(n, n, n, y, addreferences) {
 	return ret;
 }
 
-static retvalue remove_from_target(struct distribution *distribution, struct trackingdata *trackingdata, struct target *target, int count, const char * const *names, int *todo, bool *gotremoved) {
+static retvalue remove_from_target(struct distribution *distribution, struct trackingdata *trackingdata, struct target *target, int count, struct nameandversion *nameandversion, int *remaining) {
 	retvalue result, r;
 	int i;
 
 	result = RET_NOTHING;
 	for (i = 0 ; i < count ; i++){
 		r = target_removepackage(target, distribution->logger,
-				names[i], trackingdata);
+				nameandversion[i].name, nameandversion[i].version, trackingdata);
 		RET_UPDATE(distribution->status, r);
 		if (RET_IS_OK(r)) {
-			if (!gotremoved[i])
-				(*todo)--;
-			gotremoved[i] = true;
+			if (!nameandversion[i].found)
+				(*remaining)--;
+			nameandversion[i].found = true;
 		}
 		RET_UPDATE(result, r);
 	}
@@ -668,9 +669,10 @@ ACTION_D(y, n, y, remove) {
 	retvalue result, r;
 	struct distribution *distribution;
 	struct target *t;
-	bool *gotremoved;
-	int todo;
-
+	struct nameandversion data[argc-2];
+	char *delimiter;
+	int i;
+	int remaining;
 	trackingdb tracks;
 	struct trackingdata trackingdata;
 
@@ -702,12 +704,21 @@ ACTION_D(y, n, y, remove) {
 		}
 	}
 
-	todo = argc-2;
-	gotremoved = nzNEW(argc - 2, bool);
+	for (i = 0 ; i < argc-2 ; i++) {
+		data[i].found = false;
+		r = splitnameandversion(argv[2 + i], &data[i].name, &data[i].version);
+		if (RET_WAS_ERROR(r)) {
+			for (i-- ; i >= 0 ; i--) {
+				if (data[i].version != NULL)
+					free((char *)data[i].name);
+			}
+			return r;
+		}
+	}
+
+	remaining = argc-2;
 	result = RET_NOTHING;
-	if (FAILEDTOALLOC(gotremoved))
-		result = RET_ERROR_OOM;
-	else for (t = distribution->targets ; t != NULL ; t = t->next) {
+	for (t = distribution->targets ; t != NULL ; t = t->next) {
 		 if (!target_matches(t, components, architectures, packagetypes))
 			 continue;
 		 r = target_initpackagesdb(t, READWRITE);
@@ -718,8 +729,8 @@ ACTION_D(y, n, y, remove) {
 				 (distribution->tracking != dt_NONE)
 				 	? &trackingdata
 					: NULL,
-				 t, argc-2, argv+2,
-				 &todo, gotremoved);
+				 t, argc-2, data,
+				 &remaining);
 		 RET_UPDATE(result, r);
 		 r = target_closepackagesdb(t);
 		 RET_UPDATE(distribution->status, r);
@@ -736,23 +747,26 @@ ACTION_D(y, n, y, remove) {
 		r = tracking_done(tracks);
 		RET_ENDUPDATE(result, r);
 	}
-	if (verbose >= 0 && !RET_WAS_ERROR(result) && todo > 0) {
-		int i = argc - 2;
-
+	if (verbose >= 0 && !RET_WAS_ERROR(result) && remaining > 0) {
 		(void)fputs("Not removed as not found: ", stderr);
-		while (i > 0) {
-			i--;
-			assert(gotremoved != NULL);
-			if (!gotremoved[i]) {
-				(void)fputs(argv[2 + i], stderr);
-				todo--;
-				if (todo > 0)
-					(void)fputs(", ", stderr);
+		delimiter = "";
+		for (i = 0; i < argc - 2; i++) {
+			if (!data[i].found) {
+				if (data[i].version == NULL) {
+					fprintf(stderr, "%s%s", delimiter, data[i].name);
+				} else {
+					fprintf(stderr, "%s%s=%s", delimiter, data[i].name, data[i].version);
+				}
+				remaining--;
+				delimiter = ", ";
 			}
 		}
 		(void)fputc('\n', stderr);
 	}
-	free(gotremoved);
+	for (i = 0; i < argc - 2; i++) {
+		if (data[i].version != NULL)
+			free((char *)data[i].name);
+	}
 	return result;
 }
 
@@ -762,12 +776,12 @@ struct removesrcdata {
 	bool found;
 };
 
-static retvalue package_source_fits(UNUSED(struct distribution *di), struct target *target, const char *packagename, const char *control, void *data) {
+static retvalue package_source_fits(UNUSED(struct distribution *di), struct target *target, const char *packagename, const struct packagedata *packagedata, void *data) {
 	struct removesrcdata *d = data;
 	char *sourcename, *sourceversion;
 	retvalue r;
 
-	r = target->getsourceandversion(control, packagename,
+	r = target->getsourceandversion(packagedata->chunk, packagename,
 			&sourcename, &sourceversion);
 	if (!RET_IS_OK(r))
 		return r;
@@ -898,44 +912,13 @@ ACTION_D(n, n, y, removesrcs) {
 	}
 	for (i = 0 ; i < argc-2 ; i++) {
 		data[i].found = false;
-		data[i].sourcename = argv[2 + i];
-		data[i].sourceversion = index(data[i].sourcename, '=');
-		if (data[i].sourceversion != NULL) {
-			if (index(data[i].sourceversion+1, '=') != NULL) {
-				fprintf(stderr,
-"Cannot parse '%s': more than one '='\n",
-						data[i].sourcename);
-				data[i].sourcename = NULL;
-				r = RET_ERROR;
-			} else if (data[i].sourceversion[1] == '\0') {
-				fprintf(stderr,
-"Cannot parse '%s': no version after '='\n",
-						data[i].sourcename);
-				data[i].sourcename = NULL;
-				r = RET_ERROR;
-			} else if (data[i].sourceversion == data[i].sourcename) {
-				fprintf(stderr,
-"Cannot parse '%s': no source name found before the '='\n",
-						data[i].sourcename);
-				data[i].sourcename = NULL;
-				r = RET_ERROR;
-			} else {
-				data[i].sourcename = strndup(data[i].sourcename,
-						data[i].sourceversion
-						- data[i].sourcename);
-				if (FAILEDTOALLOC(data[i].sourcename))
-					r = RET_ERROR_OOM;
-				else
-					r = RET_OK;
-			}
-			if (RET_WAS_ERROR(r)) {
-				for (i-- ; i >= 0 ; i--) {
-					if (data[i].sourceversion != NULL)
-						free((char*)data[i].sourcename);
-				}
-				return r;
+		r = splitnameandversion(argv[2 + i], &data[i].sourcename, &data[i].sourceversion);
+		if (RET_WAS_ERROR(r)) {
+			for (i-- ; i >= 0 ; i--) {
+				if (data[i].sourceversion != NULL)
+					free((char *)data[i].sourcename);
 			}
-			data[i].sourceversion++;
+			return r;
 		}
 	}
 	data[i].sourcename = NULL;
@@ -959,10 +942,10 @@ ACTION_D(n, n, y, removesrcs) {
 	return r;
 }
 
-static retvalue package_matches_condition(UNUSED(struct distribution *di), struct target *target, UNUSED(const char *pa), const char *control, void *data) {
+static retvalue package_matches_condition(UNUSED(struct distribution *di), struct target *target, UNUSED(const char *pa), const struct packagedata *packagedata, void *data) {
 	term *condition = data;
 
-	return term_decidechunktarget(condition, control, target);
+	return term_decidechunktarget(condition, packagedata->chunk, target);
 }
 
 ACTION_D(y, n, y, removefilter) {
@@ -1029,7 +1012,7 @@ ACTION_D(y, n, y, removefilter) {
 	return result;
 }
 
-static retvalue package_matches_glob(UNUSED(struct distribution *di), UNUSED(struct target *ta), const char *packagename, UNUSED(const char *control), void *data) {
+static retvalue package_matches_glob(UNUSED(struct distribution *di), UNUSED(struct target *ta), const char *packagename, UNUSED(const struct packagedata *packagedata), void *data) {
 	if (globmatch(packagename, data))
 		return RET_OK;
 	else
@@ -1172,41 +1155,39 @@ ACTION_B(y, n, y, buildneeded) {
 }
 
 static retvalue list_in_target(struct target *target, const char *packagename) {
+	struct packagedata packagedata;
+	struct target_cursor iterator;
 	retvalue r, result;
-	char *control;
 
 	if (listmax == 0)
 		return RET_NOTHING;
 
-	r = target_initpackagesdb(target, READONLY);
-	if (!RET_IS_OK(r))
-		return r;
-
-	result = table_getrecord(target->packages, packagename, &control);
+	result = target_openduplicateiterator(target, READONLY, packagename, &iterator, &packagedata);
 	if (RET_IS_OK(result)) {
-		if (listskip <= 0) {
-			r = listformat_print(listformat, target,
-					packagename, control);
-			RET_UPDATE(result, r);
-			if (listmax > 0)
-				listmax--;
-		} else
-			listskip--;
-		free(control);
+		do {
+			if (listskip <= 0) {
+				r = listformat_print(listformat, target,
+						packagename, &packagedata);
+				RET_UPDATE(result, r);
+				if (listmax > 0)
+					listmax--;
+			} else
+				listskip--;
+		} while (target_nextpackage(&iterator, NULL, &packagedata));
+		r = target_closeiterator(&iterator);
+		RET_ENDUPDATE(result, r);
 	}
-	r = target_closepackagesdb(target);
-	RET_ENDUPDATE(result, r);
 	return result;
 }
 
-static retvalue list_package(UNUSED(struct distribution *dummy2), struct target *target, const char *package, const char *control, UNUSED(void *dummy3)) {
+static retvalue list_package(UNUSED(struct distribution *dummy2), struct target *target, const char *package, const struct packagedata *packagedata, UNUSED(void *dummy3)) {
 	if (listmax == 0)
 		return RET_NOTHING;
 
 	if (listskip <= 0) {
 		if (listmax > 0)
 			listmax--;
-		return listformat_print(listformat, target, package, control);
+		return listformat_print(listformat, target, package, packagedata);
 	} else {
 		listskip--;
 		return RET_NOTHING;
@@ -1252,42 +1233,39 @@ struct lspart {
 	struct lsversion *versions;
 };
 
-static retvalue newlsversion(struct lsversion **versions_p, /*@only@*/char *version, architecture_t architecture) {
+static retvalue newlsversion(struct lsversion **versions_p, /*@only@*/const char *version, architecture_t architecture) {
 	struct lsversion *v, **v_p;
 
 	for (v_p = versions_p ; (v = *v_p) != NULL ; v_p = &v->next) {
 		if (strcmp(v->version, version) != 0)
 			continue;
-		free(version);
 		return atomlist_add_uniq(&v->architectures, architecture);
 	}
 	v = zNEW(struct lsversion);
 	if (FAILEDTOALLOC(v))
 		return RET_ERROR_OOM;
 	*v_p = v;
-	v->version = version;
+	v->version = strdup(version);
+	if (FAILEDTOALLOC(v->version))
+		return RET_ERROR_OOM;
 	return atomlist_add(&v->architectures, architecture);
 }
 
 static retvalue ls_in_target(struct target *target, const char *packagename, struct lsversion **versions_p) {
 	retvalue r, result;
-	char *control, *version;
-
-	r = target_initpackagesdb(target, READONLY);
-	if (!RET_IS_OK(r))
-		return r;
+	struct packagedata packagedata;
+	struct target_cursor iterator;
 
-	result = table_getrecord(target->packages, packagename, &control);
+	result = target_openduplicateiterator(target, READONLY, packagename, &iterator, &packagedata);
 	if (RET_IS_OK(result)) {
-		r = target->getversion(control, &version);
-		if (RET_IS_OK(r))
-			r = newlsversion(versions_p, version,
-					target->architecture);
-		free(control);
-		RET_UPDATE(result, r);
+		do {
+			r = newlsversion(versions_p, packagedata.version, target->architecture);
+			RET_UPDATE(result, r);
+		} while (target_nextpackage(&iterator, NULL, &packagedata));
+
+		r = target_closeiterator(&iterator);
+		RET_ENDUPDATE(result, r);
 	}
-	r = target_closepackagesdb(target);
-	RET_ENDUPDATE(result, r);
 	return result;
 }
 
@@ -1419,20 +1397,20 @@ ACTION_B(y, n, y, lsbycomponent) {
 	return printlsparts(argv[1], first);
 }
 
-static retvalue listfilterprint(UNUSED(struct distribution *di), struct target *target, const char *packagename, const char *control, void *data) {
+static retvalue listfilterprint(UNUSED(struct distribution *di), struct target *target, const char *packagename, const struct packagedata *packagedata, void *data) {
 	term *condition = data;
 	retvalue r;
 
 	if (listmax == 0)
 		return RET_NOTHING;
 
-	r = term_decidechunktarget(condition, control, target);
+	r = term_decidechunktarget(condition, packagedata->chunk, target);
 	if (RET_IS_OK(r)) {
 		if (listskip <= 0) {
 			if (listmax > 0)
 				listmax--;
 			r = listformat_print(listformat, target,
-					packagename, control);
+					packagename, packagedata);
 		} else {
 			listskip--;
 			r = RET_NOTHING;
@@ -1465,7 +1443,7 @@ ACTION_B(y, n, y, listfilter) {
 	return result;
 }
 
-static retvalue listmatchprint(UNUSED(struct distribution *di), struct target *target, const char *packagename, const char *control, void *data) {
+static retvalue listmatchprint(UNUSED(struct distribution *di), struct target *target, const char *packagename, const struct packagedata *packagedata, void *data) {
 	const char *glob = data;
 
 	if (listmax == 0)
@@ -1476,7 +1454,7 @@ static retvalue listmatchprint(UNUSED(struct distribution *di), struct target *t
 			if (listmax > 0)
 				listmax--;
 			return listformat_print(listformat, target,
-					packagename, control);
+					packagename, packagedata);
 		} else {
 			listskip--;
 			return RET_NOTHING;
@@ -1563,8 +1541,11 @@ ACTION_F(n, n, n, n, listchecksums) {
 ACTION_B(n, n, n, dumpcontents) {
 	retvalue result, r;
 	struct table *packages;
-	const char *package, *chunk;
+	const char *package;
 	struct cursor *cursor;
+	void *data;
+	size_t data_len;
+	struct packagedata packagedata;
 
 	assert (argc == 2);
 
@@ -1578,8 +1559,9 @@ ACTION_B(n, n, n, dumpcontents) {
 		return r;
 	}
 	result = RET_NOTHING;
-	while (cursor_nexttemp(packages, cursor, &package, &chunk)) {
-		printf("'%s' -> '%s'\n", package, chunk);
+	while (cursor_nexttempdata(packages, cursor, &package, &data, &data_len)) {
+		parse_packagedata(data, data_len, &packagedata);
+		printf("'%s' -> '%s'\n", package, packagedata.chunk);
 		result = RET_OK;
 	}
 	r = cursor_close(packages, cursor);
@@ -1926,6 +1908,8 @@ ACTION_B(y, n, y, dumppull) {
 
 ACTION_D(y, n, y, copy) {
 	struct distribution *destination, *source;
+	struct nameandversion data[argc-2];
+	int i;
 	retvalue result;
 
 	result = distribution_get(alldistributions, argv[1], true, &destination);
@@ -1947,8 +1931,26 @@ ACTION_D(y, n, y, copy) {
 	if (RET_WAS_ERROR(result))
 		return result;
 
-	return copy_by_name(destination, source, argc-3, argv+3,
+	for (i = 0 ; i < argc-3 ; i++) {
+		result = splitnameandversion(argv[3 + i], &data[i].name, &data[i].version);
+		if (RET_WAS_ERROR(result)) {
+			for (i-- ; i >= 0 ; i--) {
+				if (data[i].version != NULL)
+					free((char *)data[i].name);
+			}
+			return result;
+		}
+	}
+	data[i].name = NULL;
+	data[i].version = NULL;
+
+	result = copy_by_name(destination, source, data,
 			components, architectures, packagetypes);
+	for (i = 0 ; i < argc-3 ; i++) {
+		if (data[i].version != NULL)
+			free((char *)data[i].name);
+	}
+	return result;
 }
 
 ACTION_D(y, n, y, copysrc) {
@@ -2515,7 +2517,8 @@ ACTION_F(y, n, y, y, reoverride) {
 static retvalue repair_descriptions(struct target *target) {
 	struct target_cursor iterator;
 	retvalue result, r;
-	const char *package, *controlchunk;
+	const char *package;
+	struct packagedata packagedata;
 
 	assert(target->packages == NULL);
 	assert(target->packagetype == pt_deb || target->packagetype == pt_udeb);
@@ -2530,7 +2533,7 @@ static retvalue repair_descriptions(struct target *target) {
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &package, &controlchunk)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		char *newcontrolchunk = NULL;
 
 		if (interrupted()) {
@@ -2538,8 +2541,8 @@ static retvalue repair_descriptions(struct target *target) {
 			break;
 		}
 		/* replace it by itself to normalize the Description field */
-		r = description_addpackage(target, package, controlchunk,
-				controlchunk, NULL, &newcontrolchunk);
+		r = description_addpackage(target, package, packagedata.chunk,
+				packagedata.chunk, NULL, &newcontrolchunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
 			break;
diff --git a/names.c b/names.c
index 1f214de..eb38487 100644
--- a/names.c
+++ b/names.c
@@ -148,3 +148,47 @@ char *calc_changes_basename(const char *name, const char *version, const struct
 	assert ((size_t)(p-n) == l);
 	return n;
 }
+
+// In case version_p points to a non-NULL value, name_p needs to be freed after usage.
+retvalue splitnameandversion(const char *nameandversion, const char **name_p, const char **version_p) {
+	char *version;
+	retvalue r;
+
+	version = index(nameandversion, '=');
+	if (version != NULL) {
+		if (index(version+1, '=') != NULL) {
+			fprintf(stderr,
+"Cannot parse '%s': more than one '='\n",
+					nameandversion);
+			*name_p = NULL;
+			*version_p = NULL;
+			r = RET_ERROR;
+		} else if (version[1] == '\0') {
+			fprintf(stderr,
+"Cannot parse '%s': no version after '='\n",
+					nameandversion);
+			*name_p = NULL;
+			*version_p = NULL;
+			r = RET_ERROR;
+		} else if (version == nameandversion) {
+			fprintf(stderr,
+"Cannot parse '%s': no source name found before the '='\n",
+					nameandversion);
+			*name_p = NULL;
+			*version_p = NULL;
+			r = RET_ERROR;
+		} else {
+			*name_p = strndup(nameandversion, version - nameandversion);
+			if (FAILEDTOALLOC(*name_p))
+				r = RET_ERROR_OOM;
+			else
+				r = RET_OK;
+			*version_p = version + 1;
+		}
+	} else {
+		r = RET_OK;
+		*name_p = nameandversion;
+		*version_p = NULL;
+	}
+	return r;
+}
diff --git a/names.h b/names.h
index f03761a..e54dfa0 100644
--- a/names.h
+++ b/names.h
@@ -35,4 +35,6 @@ static inline bool endswith(const char *name, const char *suffix) {
 	return ln > ls && strcmp(name + (ln - ls), suffix) == 0;
 }
 
+retvalue splitnameandversion(const char *nameandversion, const char **name_p, const char **version_p);
+
 #endif
diff --git a/needbuild.c b/needbuild.c
index 8aaa52d..76ea834 100644
--- a/needbuild.c
+++ b/needbuild.c
@@ -149,7 +149,7 @@ struct needbuild_data { architecture_t architecture;
 	bool printarch;
 };
 
-static retvalue check_source_needs_build(struct distribution *distribution, struct target *target, const char *sourcename, const char *control, void *data) {
+static retvalue check_source_needs_build(struct distribution *distribution, struct target *target, const char *sourcename, const struct packagedata *packagedata, void *data) {
 	struct needbuild_data *d = data;
 	char *sourceversion;
 	struct strlist binary, architectures, filekeys;
@@ -160,10 +160,10 @@ static retvalue check_source_needs_build(struct distribution *distribution, stru
 	if (d->glob != NULL && !globmatch(sourcename, d->glob))
 		return RET_NOTHING;
 
-	r = target->getversion(control, &sourceversion);
+	r = target->getversion(packagedata->chunk, &sourceversion);
 	if (!RET_IS_OK(r))
 		return r;
-	r = chunk_getwordlist(control, "Architecture", &architectures);
+	r = chunk_getwordlist(packagedata->chunk, "Architecture", &architectures);
 	if (RET_IS_OK(r)) {
 		bool skip = true;
 		const char *req = atoms_architectures[d->architecture];
@@ -210,12 +210,12 @@ static retvalue check_source_needs_build(struct distribution *distribution, stru
 			return RET_NOTHING;
 		}
 	}
-	r = chunk_getwordlist(control, "Binary", &binary);
+	r = chunk_getwordlist(packagedata->chunk, "Binary", &binary);
 	if (!RET_IS_OK(r)) {
 		free(sourceversion);
 		return r;
 	}
-	r = target->getfilekeys(control, &filekeys);
+	r = target->getfilekeys(packagedata->chunk, &filekeys);
 	if (!RET_IS_OK(r)) {
 		strlist_done(&binary);
 		free(sourceversion);
diff --git a/packagedata.c b/packagedata.c
new file mode 100644
index 0000000..29b3b58
--- /dev/null
+++ b/packagedata.c
@@ -0,0 +1,82 @@
+#include <config.h>
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "error.h"
+#include "packagedata.h"
+
+// The return structure packagedata must already be allocated.
+// A datablock is allocated on success and packagedata_free() needs to be called to free it.
+retvalue packagedata_create(const char *version, const char *controlchunk, /*@out@*/struct packagedata *packagedata) {
+	size_t version_len;
+	size_t controlchunk_len;
+	retvalue result;
+
+	assert (packagedata != NULL);
+
+	version_len = strlen(version) + 1;
+	controlchunk_len = strlen(controlchunk) + 1;
+	packagedata->data_len = version_len + controlchunk_len + sizeof(int64_t) +
+			sizeof(struct fields_len);
+	packagedata->data = malloc(packagedata->data_len);
+	if (likely(packagedata->data != NULL)) {
+		packagedata->version = (char*)packagedata->data;
+		packagedata->chunk = (char*)((size_t)packagedata->data + version_len);
+		packagedata->added = (int64_t*)((size_t)packagedata->chunk + controlchunk_len);
+		packagedata->fields_len = (struct fields_len*)((size_t)packagedata->data + packagedata->data_len) - 1;
+
+		memcpy(packagedata->version, version, version_len);
+		memcpy(packagedata->chunk, controlchunk, controlchunk_len);
+		*packagedata->added = time(NULL);
+		packagedata->fields_len->chunk_len = controlchunk_len;
+		packagedata->fields_len->version_len = version_len;
+		packagedata->fields_len->number_of_fields = 3;
+		result = RET_OK;
+	} else {
+		setzero(struct packagedata, packagedata);
+		result = RET_ERROR_OOM;
+	}
+	return result;
+}
+
+// The return structure packagedata must already be allocated.
+retvalue parse_packagedata(void *data, const size_t data_len, /*@out@*/struct packagedata *packagedata) {
+	size_t expected_len;
+
+	assert (packagedata != NULL);
+
+	packagedata->data = data;
+	packagedata->data_len = data_len;
+
+	if (unlikely(data_len < sizeof(struct fields_len))) {
+		fprintf(stderr, "Database returned corrupted (too small) data (%zu < %zu)!\n",
+		        data_len, sizeof(struct fields_len));
+		return RET_ERROR;
+	}
+	packagedata->fields_len = (struct fields_len*)((size_t)packagedata->data + packagedata->data_len) - 1;
+	packagedata->version = (char*)packagedata->data;
+	packagedata->chunk = (char*)((size_t)packagedata->data + packagedata->fields_len->version_len);
+	packagedata->added = (int64_t*)((size_t)packagedata->chunk + packagedata->fields_len->chunk_len);
+
+	expected_len = packagedata->fields_len->version_len + packagedata->fields_len->chunk_len +
+			sizeof(int64_t) + sizeof(struct fields_len);
+	if (unlikely(data_len < expected_len)) {
+		fprintf(stderr, "Database returned corrupted (too small) data (%zu < %zu)!\n",
+		        data_len, expected_len);
+		return RET_ERROR;
+	} else if (unlikely(packagedata->fields_len->number_of_fields < 3)) {
+		fprintf(stderr, "Database returned data with %i fields, but at least 3 are required!",
+		        packagedata->fields_len->number_of_fields);
+		return RET_ERROR;
+	} else if (unlikely(packagedata->version[packagedata->fields_len->version_len-1] != '\0' ||
+	                    packagedata->chunk[packagedata->fields_len->chunk_len-1] != '\0')) {
+		fprintf(stderr, "Database returned corrupted (not null-terminated) strings!");
+		return RET_ERROR;
+	}
+	return RET_OK;
+}
diff --git a/packagedata.h b/packagedata.h
new file mode 100644
index 0000000..14356e7
--- /dev/null
+++ b/packagedata.h
@@ -0,0 +1,61 @@
+#ifndef REPREPRO_PACKAGEDATA_H
+#define REPREPRO_PACKAGEDATA_H
+
+#include <stdint.h>
+
+#include "error.h"
+
+struct __attribute__((__packed__)) fields_len {
+	uint32_t chunk_len;
+	uint32_t version_len;
+	int8_t number_of_fields;
+};
+
+/* On-disk format of the package data:
+ *
+ * (variable length) version string with ending '\0'
+ * (variable length) control chunk string with ending '\0'
+ * int64_t added timestamp
+ * uint32_t chunk_len
+ * uint32_t version_len
+ * int8_t number_of_fields = 3
+ */
+struct packagedata {
+	// data points to continuous memory block containing all fields (similar to a struct)
+	void *data;
+	size_t data_len;
+	// The following fields point into the data memory block
+	char *version;
+	char *chunk;
+	int64_t *added;
+	struct fields_len *fields_len;
+};
+
+// Free dynamic data structures inside struct packagedata.
+static inline void packagedata_free(struct packagedata *packagedata) {
+	free(packagedata->data);
+	setzero(struct packagedata, packagedata);
+}
+
+static inline const char *packagedata_getversion(const void *data) {
+	return (char*)data;
+}
+
+static inline char *packagedata_primarykey(const char *packagename, const char *version) {
+	char *key;
+
+	assert (packagename != NULL);
+	assert (version != NULL);
+	key = malloc(strlen(packagename) + 1 + strlen(version) + 1);
+	if (key != NULL) {
+		strcpy(key, packagename);
+		strcat(key, "|");
+		strcat(key, version);
+	}
+	return key;
+}
+
+retvalue packagedata_create(const char *version, const char *controlchunk, /*@out@*/struct packagedata *packagedata);
+retvalue parse_packagedata(void *data, const size_t data_len, /*@out@*/struct packagedata *packagedata);
+
+#endif
diff --git a/printlistformat.c b/printlistformat.c
index d16d016..54a8530 100644
--- a/printlistformat.c
+++ b/printlistformat.c
@@ -32,14 +32,14 @@
 #include "printlistformat.h"
 #include "dirs.h"
 
-retvalue listformat_print(const char *listformat, const struct target *target, const char *package, const char *control) {
+retvalue listformat_print(const char *listformat, const struct target *target, const char *package, const struct packagedata *packagedata) {
 	retvalue r;
 	const char *p, *q;
 
 	if (listformat == NULL) {
 		char *version;
 
-		r = target->getversion(control, &version);
+		r = target->getversion(packagedata->chunk, &version);
 		if (RET_IS_OK(r)) {
 			printf( "%s: %s %s\n",
 					target->identifier, package, version);
@@ -101,7 +101,7 @@ retvalue listformat_print(const char *listformat, const struct target *target, c
 		           || (q - p == 14 && strncasecmp(p, "{$fullfilename", 14) == 0)
 		           || (q - p ==  9 && strncasecmp(p, "{$filekey", 9) == 0)) {
 			struct strlist filekeys;
-			r = target->getfilekeys(control, &filekeys);
+			r = target->getfilekeys(packagedata->chunk, &filekeys);
 			if (RET_WAS_ERROR(r))
 				return r;
 			if (RET_IS_OK(r) && filekeys.count > 0) {
@@ -142,7 +142,7 @@ retvalue listformat_print(const char *listformat, const struct target *target, c
 			v = atoms_components[target->component];
 		} else if (q - p == 8 && strncasecmp(p, "{$source", 8) == 0) {
 			char *dummy = NULL;
-			r = target->getsourceandversion(control, package,
+			r = target->getsourceandversion(packagedata->chunk, package,
 					&value, &dummy);
 			if (RET_WAS_ERROR(r))
 				return r;
@@ -155,7 +155,7 @@ retvalue listformat_print(const char *listformat, const struct target *target, c
 			}
 		} else if (q - p == 15 && strncasecmp(p, "{$sourceversion", 15) == 0) {
 			char *dummy = NULL;
-			r = target->getsourceandversion(control, package,
+			r = target->getsourceandversion(packagedata->chunk, package,
 					&dummy, &value);
 			if (RET_WAS_ERROR(r))
 				return r;
@@ -173,7 +173,7 @@ retvalue listformat_print(const char *listformat, const struct target *target, c
 			char *variable = strndup(p + 1, q - (p + 1));
 			if (FAILEDTOALLOC(variable))
 				return RET_ERROR_OOM;
-			r = chunk_getwholedata(control, variable, &value);
+			r = chunk_getwholedata(packagedata->chunk, variable, &value);
 			free(variable);
 			if (RET_WAS_ERROR(r))
 				return r;
diff --git a/printlistformat.h b/printlistformat.h
index 6010fee..73df48e 100644
--- a/printlistformat.h
+++ b/printlistformat.h
@@ -1,6 +1,8 @@
 #ifndef REPREPRO_PRINTLISTFORMAT
 #define REPREPRO_PRINTLISTFORMAT
 
-retvalue listformat_print(const char *, const struct target *, const char *, const char *);
+#include "packagedata.h"
+
+retvalue listformat_print(const char *, const struct target *, const char *, const struct packagedata *);
 
 #endif
diff --git a/reference.c b/reference.c
index c16b6bf..d796b92 100644
--- a/reference.c
+++ b/reference.c
@@ -159,7 +159,7 @@ retvalue references_remove(const char *neededby) {
 	l = strlen(neededby);
 
 	result = RET_NOTHING;
-	while (cursor_nexttempdata(rdb_references, cursor,
+	while (cursor_nexttempstring(rdb_references, cursor,
 				&found_to, &found_by, &datalen)) {
 
 		if (datalen >= l && strncmp(found_by, neededby, l) == 0 &&
diff --git a/release.c b/release.c
index d3bfaea..00ffdeb 100644
--- a/release.c
+++ b/release.c
@@ -1489,7 +1489,7 @@ static retvalue storechecksums(struct release *release) {
 		if (!RET_IS_OK(r))
 			continue;
 
-		r = table_adduniqsizedrecord(release->cachedb,
+		r = table_adduniqsizedstring(release->cachedb,
 				file->relativefilename, combinedchecksum, len+1,
 				false, false);
 		RET_UPDATE(result, r);
diff --git a/sizes.c b/sizes.c
index 34f7671..3ae0c8d 100644
--- a/sizes.c
+++ b/sizes.c
@@ -75,7 +75,7 @@ static retvalue count_sizes(struct cursor *cursor, bool specific, struct distrib
 	bool snapshot;
 	unsigned long long all = 0, onlyall = 0;
 
-	while (cursor_nexttempdata(rdb_references, cursor,
+	while (cursor_nexttempstring(rdb_references, cursor,
 				&key, &data, &len)) {
 		if (last_file == NULL || strcmp(last_file, key) != 0) {
 			if (last_file != NULL) {
diff --git a/sourcecheck.c b/sourcecheck.c
index 58d29cd..ae1d1c3 100644
--- a/sourcecheck.c
+++ b/sourcecheck.c
@@ -70,7 +70,8 @@ static retvalue collect_source_versions(struct distribution *d, struct info_sour
 	struct info_source *root = NULL, *last = NULL;
 	struct target *t;
 	struct target_cursor target_cursor = TARGET_CURSOR_ZERO;
-	const char *name, *chunk;
+	const char *name;
+	struct packagedata packagedata;
 	retvalue result = RET_NOTHING, r;
 
 	for (t = d->targets ; t != NULL ; t = t->next) {
@@ -81,12 +82,12 @@ static retvalue collect_source_versions(struct distribution *d, struct info_sour
 			RET_UPDATE(result, r);
 			break;
 		}
-		while (target_nextpackage(&target_cursor, &name, &chunk)) {
+		while (target_nextpackage(&target_cursor, &name, &packagedata)) {
 			char *version;
 			struct info_source **into = NULL;
 			struct info_source_version *v;
 
-			r = t->getversion(chunk, &version);
+			r = t->getversion(packagedata.chunk, &version);
 			if (!RET_IS_OK(r)) {
 				RET_UPDATE(result, r);
 				continue;
@@ -185,7 +186,8 @@ static retvalue collect_source_versions(struct distribution *d, struct info_sour
 static retvalue process_binaries(struct distribution *d, struct info_source *sources, retvalue (*action)(struct distribution *, struct target *, const char *, const char *, const char *, const char *, void *), void *privdata) {
 	struct target *t;
 	struct target_cursor target_cursor = TARGET_CURSOR_ZERO;
-	const char *name, *chunk;
+	const char *name = NULL;
+	struct packagedata packagedata;
 	retvalue result = RET_NOTHING, r;
 
 	for (t = d->targets ; t != NULL ; t = t->next) {
@@ -196,12 +198,12 @@ static retvalue process_binaries(struct distribution *d, struct info_source *sou
 			RET_UPDATE(result, r);
 			break;
 		}
-		while (target_nextpackage(&target_cursor, &name, &chunk)) {
+		while (target_nextpackage(&target_cursor, &name, &packagedata)) {
 			char *source, *version;
 			struct info_source *s;
 			struct info_source_version *v;
 
-			r = t->getsourceandversion(chunk, name,
+			r = t->getsourceandversion(packagedata.chunk, name,
 					&source, &version);
 			if (!RET_IS_OK(r)) {
 				RET_UPDATE(result, r);
@@ -221,7 +223,7 @@ static retvalue process_binaries(struct distribution *d, struct info_source *sou
 				v->used = true;
 			} else if (action != NULL) {
 				r = action(d, t,
-						name, source, version, chunk,
+						name, source, version, packagedata.chunk,
 						privdata);
 				RET_UPDATE(result, r);
 			}
diff --git a/target.c b/target.c
index 02ff38d..b3d7c4a 100644
--- a/target.c
+++ b/target.c
@@ -42,6 +42,7 @@
 #include "files.h"
 #include "descriptions.h"
 #include "target.h"
+#include "packagedata.h"
 
 static char *calc_identifier(const char *codename, component_t component, architecture_t architecture, packagetype_t packagetype) {
 	assert (strchr(codename, '|') == NULL);
@@ -222,28 +223,29 @@ retvalue target_closepackagesdb(struct target *target) {
 }
 
 /* Remove a package from the given target. */
-retvalue target_removereadpackage(struct target *target, struct logger *logger, const char *name, const char *oldcontrol, struct trackingdata *trackingdata) {
+retvalue target_removereadpackage(struct target *target, struct logger *logger, const char *name, const struct packagedata *olddata, struct trackingdata *trackingdata) {
 	char *oldpversion = NULL;
 	struct strlist files;
 	retvalue result, r;
 	char *oldsource, *oldsversion;
+	char *key;
 
 	assert (target != NULL && target->packages != NULL);
-	assert (oldcontrol != NULL && name != NULL);
+	assert (olddata != NULL && olddata->data != NULL && name != NULL);
 
 	if (logger != NULL) {
 		/* need to get the version for logging, if not available */
-		r = target->getversion(oldcontrol, &oldpversion);
+		r = target->getversion(olddata->chunk, &oldpversion);
 		if (!RET_IS_OK(r))
 			oldpversion = NULL;
 	}
-	r = target->getfilekeys(oldcontrol, &files);
+	r = target->getfilekeys(olddata->chunk, &files);
 	if (RET_WAS_ERROR(r)) {
 		free(oldpversion);
 		return r;
 	}
 	if (trackingdata != NULL) {
-		r = target->getsourceandversion(oldcontrol,
+		r = target->getsourceandversion(olddata->chunk,
 				name, &oldsource, &oldsversion);
 		if (!RET_IS_OK(r)) {
 			oldsource = oldsversion = NULL;
@@ -252,9 +254,11 @@ retvalue target_removereadpackage(struct target *target, struct logger *logger,
 		oldsource = oldsversion = NULL;
 	}
 	if (verbose > 0)
-		printf("removing '%s' from '%s'...\n",
-				name, target->identifier);
-	result = table_deleterecord(target->packages, name, false);
+		printf("removing '%s=%s' from '%s'...\n",
+				name, olddata->version, target->identifier);
+	key = packagedata_primarykey(name, olddata->version);
+	result = table_deleterecord(target->packages, key, false);
+	free(key);
 	if (RET_IS_OK(result)) {
 		target->wasmodified = true;
 		if (oldsource!= NULL && oldsversion != NULL) {
@@ -267,7 +271,7 @@ retvalue target_removereadpackage(struct target *target, struct logger *logger,
 		if (logger != NULL)
 			logger_log(logger, target, name,
 					NULL, oldpversion,
-					NULL, oldcontrol,
+					NULL, olddata->chunk,
 					NULL, &files,
 					NULL, NULL);
 		r = references_delete(target->identifier, &files, NULL);
@@ -279,13 +283,13 @@ retvalue target_removereadpackage(struct target *target, struct logger *logger,
 }
 
 /* Remove a package from the given target. */
-retvalue target_removepackage(struct target *target, struct logger *logger, const char *name, struct trackingdata *trackingdata) {
-	char *oldchunk;
+retvalue target_removepackage(struct target *target, struct logger *logger, const char *name, const char *version, struct trackingdata *trackingdata) {
+	struct packagedata olddata;
 	retvalue r;
 
 	assert(target != NULL && target->packages != NULL && name != NULL);
 
-	r = table_getrecord(target->packages, name, &oldchunk);
+	r = target_getpackage(target, name, version, &olddata);
 	if (RET_WAS_ERROR(r)) {
 		return r;
 	}
@@ -296,8 +300,8 @@ retvalue target_removepackage(struct target *target, struct logger *logger, cons
 		return RET_NOTHING;
 	}
 	r = target_removereadpackage(target, logger,
-			name, oldchunk, trackingdata);
-	free(oldchunk);
+			name, &olddata, trackingdata);
+	packagedata_free(&olddata);
 	return r;
 }
 
@@ -306,28 +310,30 @@ retvalue target_removepackage(struct target *target, struct logger *logger, cons
 retvalue target_removepackage_by_cursor(struct target_cursor *tc, struct logger *logger, struct trackingdata *trackingdata) {
 	struct target * const target = tc->target;
 	const char * const name = tc->lastname;
-	const char * const control = tc->lastcontrol;
+	struct packagedata packagedata;
 	char *oldpversion = NULL;
 	struct strlist files;
 	retvalue result, r;
 	char *oldsource, *oldsversion;
 
+	parse_packagedata(tc->lastdata, tc->lastdata_len, &packagedata);
+
 	assert (target != NULL && target->packages != NULL);
-	assert (name != NULL && control != NULL);
+	assert (name != NULL && packagedata.data != NULL);
 
 	if (logger != NULL) {
 		/* need to get the version for logging, if not available */
-		r = target->getversion(control, &oldpversion);
+		r = target->getversion(packagedata.chunk, &oldpversion);
 		if (!RET_IS_OK(r))
 			oldpversion = NULL;
 	}
-	r = target->getfilekeys(control, &files);
+	r = target->getfilekeys(packagedata.chunk, &files);
 	if (RET_WAS_ERROR(r)) {
 		free(oldpversion);
 		return r;
 	}
 	if (trackingdata != NULL) {
-		r = target->getsourceandversion(control,
+		r = target->getsourceandversion(packagedata.chunk,
 				name, &oldsource, &oldsversion);
 		if (!RET_IS_OK(r)) {
 			oldsource = oldsversion = NULL;
@@ -351,7 +357,7 @@ retvalue target_removepackage_by_cursor(struct target_cursor *tc, struct logger
 		if (logger != NULL)
 			logger_log(logger, target, name,
 					NULL, oldpversion,
-					NULL, control,
+					NULL, packagedata.chunk,
 					NULL, &files,
 					NULL, NULL);
 		r = references_delete(target->identifier, &files, NULL);
@@ -362,13 +368,16 @@ retvalue target_removepackage_by_cursor(struct target_cursor *tc, struct logger
 	return result;
 }
 
-static retvalue addpackages(struct target *target, const char *packagename, const char *controlchunk, /*@null@*/const char *oldcontrolchunk, const char *version, /*@null@*/const char *oldversion, const struct strlist *files, /*@only@*//*@null@*/struct strlist *oldfiles, /*@null@*/struct logger *logger, /*@null@*/struct trackingdata *trackingdata, architecture_t architecture, /*@null@*//*@only@*/char *oldsource, /*@null@*//*@only@*/char *oldsversion, /*@null@*/const char *causingrule, /*@null@*/const char *suitefrom) {
+static retvalue addpackages(struct target *target, const char *packagename, const char *controlchunk, const char *version, /*@null@*/const struct packagedata *oldpackage, const struct strlist *files, /*@only@*//*@null@*/struct strlist *oldfiles, /*@null@*/struct logger *logger, /*@null@*/struct trackingdata *trackingdata, architecture_t architecture, /*@null@*//*@only@*/char *oldsource, /*@null@*//*@only@*/char *oldsversion, /*@null@*/const char *causingrule, /*@null@*/const char *suitefrom) {
 
 	retvalue result, r;
+	char *key;
+	struct packagedata packagedata;
 	struct table *table = target->packages;
 	enum filetype filetype;
 
 	assert (atom_defined(architecture));
+	assert (oldpackage != NULL);
 
 	if (architecture == architecture_source)
 		filetype = ft_SOURCE;
@@ -387,14 +396,23 @@ static retvalue addpackages(struct target *target, const char *packagename, cons
 		return r;
 	}
 
+	r = packagedata_create(version, controlchunk, &packagedata);
+	if (RET_WAS_ERROR(r)) {
+		if (oldfiles != NULL)
+			strlist_done(oldfiles);
+		return r;
+	}
+
 	/* Add package to the distribution's database */
 
-	if (oldcontrolchunk != NULL) {
-		result = table_replacerecord(table, packagename, controlchunk);
+	key = packagedata_primarykey(packagename, version);
+	if (oldpackage->data != NULL) {
+		result = table_replacesizedrecord(table, packagename, packagedata.data, packagedata.data_len);
 
 	} else {
-		result = table_adduniqrecord(table, packagename, controlchunk);
+		result = table_adduniqsizedrecord(table, key, packagedata.data, packagedata.data_len, false, false);
 	}
+	free(key);
 
 	if (RET_WAS_ERROR(result)) {
 		if (oldfiles != NULL)
@@ -404,8 +422,8 @@ static retvalue addpackages(struct target *target, const char *packagename, cons
 
 	if (logger != NULL)
 		logger_log(logger, target, packagename,
-				version, oldversion,
-				controlchunk, oldcontrolchunk,
+				version, oldpackage->version,
+				controlchunk, oldpackage->chunk,
 				files, oldfiles, causingrule, suitefrom);
 
 	r = trackingdata_insert(trackingdata, filetype, files,
@@ -423,124 +441,182 @@ static retvalue addpackages(struct target *target, const char *packagename, cons
 	return result;
 }
 
+// If version is NULL, return the latest version of the specified package name.
+// The return structure packagedata must already be allocated.
+retvalue target_getpackage(struct target *target, const char *name, const char *version, /*@out*/struct packagedata *packagedata) {
+	void *data;
+	size_t data_len;
+	retvalue r;
+
+	if (version == NULL) {
+		r = table_getcomplexrecord(target->packages, true, name, &data, &data_len);
+	} else {
+		char *key;
+		key = packagedata_primarykey(name, version);
+		r = table_getcomplexrecord(target->packages, false, key, &data, &data_len);
+		free(key);
+	}
+	if (!RET_IS_OK(r)) {
+		// Error case or no package found.
+		setzero(struct packagedata, packagedata);
+		return r;
+	}
+	return parse_packagedata(data, data_len, packagedata);
+}
+
 retvalue target_addpackage(struct target *target, struct logger *logger, const char *name, const char *version, const char *control, const struct strlist *filekeys, bool downgrade, struct trackingdata *trackingdata, architecture_t architecture, const char *causingrule, const char *suitefrom, struct description *description) {
 	struct strlist oldfilekeys, *ofk;
+	struct packagedata oldpackage;
 	char *newcontrol;
-	char *oldcontrol, *oldsource, *oldsversion;
-	char *oldpversion;
+	char *oldsource, *oldsversion;
 	retvalue r;
+	// TODO: make keep_old user configurable.
+	bool keep_old = true;
+	// Overwrite existing package versions.
+	bool overwrite_existing;
+	bool replace = true;
 
 	assert(target->packages!=NULL);
 
-	r = table_getrecord(target->packages, name, &oldcontrol);
+	overwrite_existing = downgrade;
+
+	r = target_getpackage(target, name, NULL, &oldpackage);
 	if (RET_WAS_ERROR(r))
 		return r;
 	if (r == RET_NOTHING) {
 		ofk = NULL;
 		oldsource = NULL;
 		oldsversion = NULL;
-		oldpversion = NULL;
-		oldcontrol = NULL;
 	} else {
+		int versioncmp;
 
-		r = target->getversion(oldcontrol, &oldpversion);
-		if (RET_WAS_ERROR(r) && !IGNORING(brokenold,
-"Error parsing old version!\n")) {
-			free(oldcontrol);
-			return r;
-		}
-		if (RET_IS_OK(r)) {
-			int versioncmp;
-
-			r = dpkgversions_cmp(version, oldpversion, &versioncmp);
-			if (RET_WAS_ERROR(r)) {
-				if (!IGNORING(brokenversioncmp,
+		r = dpkgversions_cmp(version, oldpackage.version, &versioncmp);
+		if (RET_WAS_ERROR(r)) {
+			if (!IGNORING(brokenversioncmp,
 "Parse errors processing versions of %s.\n", name)) {
-					free(oldpversion);
-					free(oldcontrol);
-					return r;
+				packagedata_free(&oldpackage);
+				return r;
+			}
+		} else {
+			if (versioncmp == 0) {
+				// new Version is same than the old version
+				if (!overwrite_existing) {
+					fprintf(stderr,
+"Skipping inclusion of '%s' '%s' in '%s', as this version already exists.\n",
+						name, version,
+						target->identifier);
+					packagedata_free(&oldpackage);
+					return RET_NOTHING;
+				} else {
+					fprintf(stderr,
+"Warning: replacing '%s' version '%s' with equal version '%s' in '%s'!\n", name,
+						oldpackage.version, version,
+						target->identifier);
 				}
-			} else {
-				if (versioncmp <= 0) {
-					/* new Version is not newer than
-					 * old version */
-					if (!downgrade) {
-						fprintf(stderr,
+			} else if (versioncmp < 0) {
+				/* new Version is older than
+				 * old version */
+				if (keep_old) {
+					struct packagedata samepackage;
+					r = target_getpackage(target, name, version, &samepackage);
+					if (RET_WAS_ERROR(r)) {
+						packagedata_free(&oldpackage);
+						return r;
+					} else if (RET_IS_OK(r)) {
+						if (!overwrite_existing) {
+							fprintf(stderr,
+		"Skipping inclusion of '%s' '%s' in '%s', as this version already exists.\n",
+								name, version,
+								target->identifier);
+							packagedata_free(&oldpackage);
+							packagedata_free(&samepackage);
+							return RET_NOTHING;
+						} else {
+							fprintf(stderr,
+		"Warning: replacing '%s' version '%s' with equal version '%s' in '%s'!\n", name,
+								samepackage.version, version,
+								target->identifier);
+						}
+					} else { // r == RET_NOTHING
+						replace = false;
+					}
+					packagedata_free(&samepackage);
+				} else if (!downgrade) {
+					fprintf(stderr,
 "Skipping inclusion of '%s' '%s' in '%s', as it has already '%s'.\n",
-							name, version,
-							target->identifier,
-							oldpversion);
-						free(oldpversion);
-						free(oldcontrol);
-						return RET_NOTHING;
-					} else if (versioncmp < 0) {
-						fprintf(stderr,
+						name, version,
+						target->identifier,
+						oldpackage.version);
+					packagedata_free(&oldpackage);
+					return RET_NOTHING;
+				} else {
+					fprintf(stderr,
 "Warning: downgrading '%s' from '%s' to '%s' in '%s'!\n", name,
-							oldpversion, version,
-							target->identifier);
-					} else {
-						fprintf(stderr,
-"Warning: replacing '%s' version '%s' with equal version '%s' in '%s'!\n", name,
-							oldpversion, version,
-							target->identifier);
-					}
+						oldpackage.version, version,
+						target->identifier);
 				}
+			} else { // versioncmp > 0
+				replace = !keep_old;
 			}
-		} else
-			oldpversion = NULL;
-		r = target->getfilekeys(oldcontrol, &oldfilekeys);
-		ofk = &oldfilekeys;
-		if (RET_WAS_ERROR(r)) {
-			if (IGNORING(brokenold,
-"Error parsing files belonging to installed version of %s!\n", name)) {
-				ofk = NULL;
-				oldsversion = oldsource = NULL;
-			} else {
-				free(oldcontrol);
-				free(oldpversion);
-				return r;
-			}
-		} else if (trackingdata != NULL) {
-			r = target->getsourceandversion(oldcontrol,
-					name, &oldsource, &oldsversion);
+		}
+		if (replace) {
+			r = target->getfilekeys(oldpackage.chunk, &oldfilekeys);
+			ofk = &oldfilekeys;
 			if (RET_WAS_ERROR(r)) {
-				strlist_done(ofk);
 				if (IGNORING(brokenold,
-"Error searching for source name of installed version of %s!\n", name)) {
-					// TODO: free something of oldfilekeys?
+"Error parsing files belonging to installed version of %s!\n", name)) {
 					ofk = NULL;
 					oldsversion = oldsource = NULL;
 				} else {
-					free(oldcontrol);
-					free(oldpversion);
+					packagedata_free(&oldpackage);
 					return r;
 				}
+			} else if (trackingdata != NULL) {
+				r = target->getsourceandversion(oldpackage.chunk,
+						name, &oldsource, &oldsversion);
+				if (RET_WAS_ERROR(r)) {
+					strlist_done(ofk);
+					if (IGNORING(brokenold,
+"Error searching for source name of installed version of %s!\n", name)) {
+						// TODO: free something of oldfilekeys?
+						ofk = NULL;
+						oldsversion = oldsource = NULL;
+					} else {
+						packagedata_free(&oldpackage);
+						return r;
+					}
+				}
+			} else {
+				oldsversion = oldsource = NULL;
 			}
-		} else {
-			oldsversion = oldsource = NULL;
 		}
-
 	}
 	newcontrol = NULL;
-	r = description_addpackage(target, name, control, oldcontrol,
+	r = description_addpackage(target, name, control, oldpackage.chunk,
 			description, &newcontrol);
 	if (RET_IS_OK(r))
 		control = newcontrol;
-	if (!RET_WAS_ERROR(r))
-		r = addpackages(target, name, control, oldcontrol,
-			version, oldpversion,
+	if (!RET_WAS_ERROR(r)) {
+		if (!replace) {
+			packagedata_free(&oldpackage);
+			ofk = NULL;
+			oldsversion = NULL;
+			oldsource = NULL;
+		}
+		r = addpackages(target, name, control,
+			version, &oldpackage,
 			filekeys, ofk,
 			logger,
 			trackingdata, architecture, oldsource, oldsversion,
 			causingrule, suitefrom);
+	}
 	if (RET_IS_OK(r)) {
 		target->wasmodified = true;
 		if (trackingdata == NULL)
 			target->staletracking = true;
 	}
 	free(newcontrol);
-	free(oldpversion);
-	free(oldcontrol);
+	packagedata_free(&oldpackage);
 
 	return r;
 }
@@ -651,7 +727,8 @@ retvalue target_checkaddpackage(struct target *target, const char *name, const c
 retvalue target_rereference(struct target *target) {
 	retvalue result, r;
 	struct target_cursor iterator;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 
 	if (verbose > 1) {
 		if (verbose > 2)
@@ -670,10 +747,10 @@ retvalue target_rereference(struct target *target) {
 	assert (r != RET_NOTHING);
 	if (RET_WAS_ERROR(r))
 		return r;
-	while (target_nextpackage(&iterator, &package, &control)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		struct strlist filekeys;
 
-		r = target->getfilekeys(control, &filekeys);
+		r = target->getfilekeys(packagedata.chunk, &filekeys);
 		RET_UPDATE(result, r);
 		if (!RET_IS_OK(r))
 			continue;
@@ -692,12 +769,12 @@ retvalue target_rereference(struct target *target) {
 	return result;
 }
 
-retvalue package_referenceforsnapshot(UNUSED(struct distribution *di), struct target *target, const char *package, const char *chunk, void *data) {
+retvalue package_referenceforsnapshot(UNUSED(struct distribution *di), struct target *target, const char *package, const struct packagedata *packagedata, void *data) {
 	const char *identifier = data;
 	struct strlist filekeys;
 	retvalue r;
 
-	r = target->getfilekeys(chunk, &filekeys);
+	r = target->getfilekeys(packagedata->chunk, &filekeys);
 	if (RET_WAS_ERROR(r))
 		return r;
 	if (verbose > 15) {
@@ -711,14 +788,14 @@ retvalue package_referenceforsnapshot(UNUSED(struct distribution *di), struct ta
 	return r;
 }
 
-retvalue package_check(UNUSED(struct distribution *di), struct target *target, const char *package, const char *chunk, UNUSED(void *pd)) {
+retvalue package_check(UNUSED(struct distribution *di), struct target *target, const char *package, const struct packagedata *packagedata, UNUSED(void *pd)) {
 	struct checksumsarray files;
 	struct strlist expectedfilekeys;
 	char *dummy, *version;
 	retvalue result = RET_OK, r;
 	architecture_t package_architecture;
 
-	r = target->getversion(chunk, &version);
+	r = target->getversion(packagedata->chunk, &version);
 	if (!RET_IS_OK(r)) {
 		fprintf(stderr,
 "Error extraction version number from package control info of '%s'!\n",
@@ -727,7 +804,7 @@ retvalue package_check(UNUSED(struct distribution *di), struct target *target, c
 			r = RET_ERROR_MISSING;
 		return r;
 	}
-	r = target->getarchitecture(chunk, &package_architecture);
+	r = target->getarchitecture(packagedata->chunk, &package_architecture);
 	if (!RET_IS_OK(r)) {
 		fprintf(stderr,
 "Error extraction architecture from package control info of '%s'!\n",
@@ -747,7 +824,7 @@ retvalue package_check(UNUSED(struct distribution *di), struct target *target, c
 		result = RET_ERROR;
 	}
 	r = target->getinstalldata(target, package, version,
-			package_architecture, chunk, &dummy,
+			package_architecture, packagedata->chunk, &dummy,
 			&expectedfilekeys, &files);
 	if (RET_WAS_ERROR(r)) {
 		fprintf(stderr,
@@ -771,7 +848,7 @@ retvalue package_check(UNUSED(struct distribution *di), struct target *target, c
 		}
 		strlist_done(&expectedfilekeys);
 	} else {
-		r = target->getchecksums(chunk, &files);
+		r = target->getchecksums(packagedata->chunk, &files);
 		if (r == RET_NOTHING)
 			r = RET_ERROR;
 		if (RET_WAS_ERROR(r)) {
@@ -807,7 +884,8 @@ retvalue package_check(UNUSED(struct distribution *di), struct target *target, c
 retvalue target_reoverride(struct target *target, struct distribution *distribution) {
 	struct target_cursor iterator;
 	retvalue result, r;
-	const char *package, *controlchunk;
+	const char *package;
+	struct packagedata packagedata;
 
 	assert(target->packages == NULL);
 	assert(distribution != NULL);
@@ -822,10 +900,10 @@ retvalue target_reoverride(struct target *target, struct distribution *distribut
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &package, &controlchunk)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		char *newcontrolchunk = NULL;
 
-		r = target->doreoverride(target, package, controlchunk,
+		r = target->doreoverride(target, package, packagedata.chunk,
 				&newcontrolchunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r)) {
@@ -875,7 +953,8 @@ static retvalue complete_package_checksums(struct target *target, const char *co
 retvalue target_redochecksums(struct target *target, struct distribution *distribution) {
 	struct target_cursor iterator;
 	retvalue result, r;
-	const char *package, *controlchunk;
+	const char *package;
+	struct packagedata packagedata;
 
 	assert(target->packages == NULL);
 	assert(distribution != NULL);
@@ -890,10 +969,10 @@ retvalue target_redochecksums(struct target *target, struct distribution *distri
 	if (!RET_IS_OK(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &package, &controlchunk)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		char *newcontrolchunk = NULL;
 
-		r = complete_package_checksums(target, controlchunk,
+		r = complete_package_checksums(target, packagedata.chunk,
 				&newcontrolchunk);
 		RET_UPDATE(result, r);
 		if (RET_WAS_ERROR(r))
@@ -942,13 +1021,13 @@ retvalue target_export(struct target *target, bool onlyneeded, bool snapshot, st
 	return result;
 }
 
-retvalue package_rerunnotifiers(struct distribution *distribution, struct target *target, const char *package, const char *chunk, UNUSED(void *data)) {
+retvalue package_rerunnotifiers(struct distribution *distribution, struct target *target, const char *package, const struct packagedata *packagedata, UNUSED(void *data)) {
 	struct logger *logger = distribution->logger;
 	struct strlist filekeys;
 	char *version;
 	retvalue r;
 
-	r = target->getversion(chunk, &version);
+	r = target->getversion(packagedata->chunk, &version);
 	if (!RET_IS_OK(r)) {
 		fprintf(stderr,
 "Error extraction version number from package control info of '%s'!\n",
@@ -957,7 +1036,7 @@ retvalue package_rerunnotifiers(struct distribution *distribution, struct target
 			r = RET_ERROR_MISSING;
 		return r;
 	}
-	r = target->getfilekeys(chunk, &filekeys);
+	r = target->getfilekeys(packagedata->chunk, &filekeys);
 	if (RET_WAS_ERROR(r)) {
 		fprintf(stderr,
 "Error extracting information about used files from package '%s'!\n",
@@ -965,7 +1044,7 @@ retvalue package_rerunnotifiers(struct distribution *distribution, struct target
 		free(version);
 		return r;
 	}
-	r = logger_reruninfo(logger, target, package, version, chunk, &filekeys);
+	r = logger_reruninfo(logger, target, package, version, packagedata->chunk, &filekeys);
 	strlist_done(&filekeys);
 	free(version);
 	return r;
diff --git a/target.h b/target.h
index b020cec..cb6d0ea 100644
--- a/target.h
+++ b/target.h
@@ -22,6 +22,7 @@
 #ifndef REPREPRO_EXPORTS_H
 #include "exports.h"
 #endif
+#include "packagedata.h"
 
 struct target;
 struct alloverrides;
@@ -89,7 +90,8 @@ struct target_cursor {
 	/*@temp@*/struct target *target;
 	struct cursor *cursor;
 	const char *lastname;
-	const char *lastcontrol;
+	void *lastdata;
+	size_t lastdata_len;
 };
 #define TARGET_CURSOR_ZERO {NULL, NULL, NULL, NULL}
 /* wrapper around initpackagesdb and table_newglobalcursor */
@@ -112,27 +114,54 @@ static inline retvalue target_openiterator(struct target *t, bool readonly, /*@o
 	tc->cursor = c;
 	return RET_OK;
 }
+
+/* wrapper around initpackagesdb and table_newduplicatecursor */
+static inline retvalue target_openduplicateiterator(struct target *t, bool readonly, const char *key, /*@out@*/struct target_cursor *tc, /*@out@*/struct packagedata *packagedata) {
+	retvalue r, r2;
+	struct cursor *c;
+	void *data;
+	size_t data_len;
+
+	r = target_initpackagesdb(t, readonly);
+	assert (r != RET_NOTHING);
+	if (RET_WAS_ERROR(r))
+		return r;
+
+	r = table_newduplicatecursor(t->packages, true, key, &c, (const void**)&data, &data_len);
+	if (!RET_IS_OK(r)) {
+		r2 = target_closepackagesdb(t);
+		RET_ENDUPDATE(r, r2);
+		return r;
+	}
+	tc->target = t;
+	tc->cursor = c;
+	tc->lastdata = data;
+	tc->lastdata_len = data_len;
+	parse_packagedata(data, data_len, packagedata);
+	return RET_OK;
+}
+
 /* wrapper around cursor_nexttemp */
-static inline bool target_nextpackage(struct target_cursor *tc, /*@out@*/const char **packagename_p, /*@out@*/const char **chunk_p) {
+static inline bool target_nextpackage(struct target_cursor *tc, /*@out@*/const char **packagename_p, /*@out@*/struct packagedata *packagedata) {
 	bool success;
-	success = cursor_nexttemp(tc->target->packages, tc->cursor,
-			&tc->lastname, &tc->lastcontrol);
+
+	success = cursor_nexttempdata(tc->target->packages, tc->cursor,
+			&tc->lastname, &tc->lastdata, &tc->lastdata_len);
 	if (success) {
-		*packagename_p = tc->lastname;
-		*chunk_p = tc->lastcontrol;
+		if (packagename_p != NULL) {
+			*packagename_p = tc->lastname;
+		}
+		parse_packagedata(tc->lastdata, tc->lastdata_len, packagedata);
 	} else {
 		tc->lastname = NULL;
-		tc->lastcontrol = NULL;
+		tc->lastdata = NULL;
+		tc->lastdata_len = 0;
+		if (packagename_p != NULL)
+			*packagename_p = NULL;
 	}
 	return success;
 }
-/* wrapper around cursor_nexttemp */
-static inline bool target_nextpackage_len(struct target_cursor *tc, /*@out@*//*@null@*/const char **packagename_p, /*@out@*/const char **chunk_p, /*@out@*/size_t *len_p) {
-	tc->lastname = NULL;
-	tc->lastcontrol = NULL;
-	return cursor_nexttempdata(tc->target->packages, tc->cursor,
-			packagename_p, chunk_p, len_p);
-}
+
 /* wrapper around cursor_close and target_closepackagesdb */
 static inline retvalue target_closeiterator(struct target_cursor *tc) {
 	retvalue result, r;
@@ -148,19 +177,20 @@ struct logger;
 struct description;
 retvalue target_addpackage(struct target *, /*@null@*/struct logger *, const char *name, const char *version, const char *control, const struct strlist *filekeys, bool downgrade, /*@null@*/struct trackingdata *, architecture_t, /*@null@*/const char *causingrule, /*@null@*/const char *suitefrom, /*@null@*/struct description *);
 retvalue target_checkaddpackage(struct target *, const char *name, const char *version, bool tracking, bool permitnewerold);
-retvalue target_removepackage(struct target *, /*@null@*/struct logger *, const char *name, struct trackingdata *);
+retvalue target_getpackage(struct target *, const char *name, const char *version, /*@out*/struct packagedata *);
+retvalue target_removepackage(struct target *, /*@null@*/struct logger *, const char *name, const char *version, struct trackingdata *);
 /* like target_removepackage, but do not read control data yourself but use available */
-retvalue target_removereadpackage(struct target *, /*@null@*/struct logger *, const char *name, const char *oldcontrol, /*@null@*/struct trackingdata *);
+retvalue target_removereadpackage(struct target *, /*@null@*/struct logger *, const char *name, const struct packagedata *olddata, /*@null@*/struct trackingdata *);
 /* Like target_removepackage, but delete the package record by cursor */
 retvalue target_removepackage_by_cursor(struct target_cursor *, /*@null@*/struct logger *, /*@null@*/struct trackingdata *);
 
-retvalue package_check(struct distribution *, struct target *, const char *, const char *, void *);
+retvalue package_check(struct distribution *, struct target *, const char *, const struct packagedata *, void *);
 retvalue target_rereference(struct target *);
-retvalue package_referenceforsnapshot(struct distribution *, struct target *, const char *, const char *, void *);
+retvalue package_referenceforsnapshot(struct distribution *, struct target *, const char *, const struct packagedata *, void *);
 retvalue target_reoverride(struct target *, struct distribution *);
 retvalue target_redochecksums(struct target *, struct distribution *);
 
-retvalue package_rerunnotifiers(struct distribution *, struct target *, const char *, const char *, void *);
+retvalue package_rerunnotifiers(struct distribution *, struct target *, const char *, const struct packagedata *, void *);
 
 static inline bool target_matches(const struct target *t, const struct atomlist *components, const struct atomlist *architectures, const struct atomlist *packagetypes) {
 	if (limitations_missed(components, t->component))
diff --git a/tracking.c b/tracking.c
index c231e90..b041e3f 100644
--- a/tracking.c
+++ b/tracking.c
@@ -1135,7 +1135,7 @@ static retvalue tracking_foreachversion(trackingdb t, struct distribution *distr
 	const char *value, *data;
 	size_t datalen;
 
-	r = table_newduplicatecursor(t->table, sourcename, &cursor,
+	r = table_newduplicatepairedcursor(t->table, sourcename, &cursor,
 			&value, &data, &datalen);
 	if (!RET_IS_OK(r))
 		return r;
@@ -1185,7 +1185,8 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 	arch_len = strlen(architecture);
 	for (i = 0 ; i < pkg->filekeys.count ; i++) {
 		const char *s, *basefilename, *filekey = pkg->filekeys.values[i];
-		char *package, *control, *source, *version;
+		char *package, *source, *version;
+		struct packagedata packagedata;
 		struct strlist filekeys;
 		bool savedstaletracking;
 
@@ -1239,7 +1240,8 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 		package = strndup(basefilename, s - basefilename);
 		if (FAILEDTOALLOC(package))
 			return RET_ERROR_OOM;
-		r = table_getrecord(target->packages, package, &control);
+		// TODO: Support multiple versions
+		r = target_getpackage(target, package, NULL, &packagedata);
 		if (RET_WAS_ERROR(r)) {
 			free(package);
 			return r;
@@ -1256,12 +1258,12 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 			free(package);
 			continue;
 		}
-		r = target->getsourceandversion(control, package,
+		r = target->getsourceandversion(packagedata.chunk, package,
 				&source, &version);
 		assert (r != RET_NOTHING);
 		if (RET_WAS_ERROR(r)) {
 			free(package);
-			free(control);
+			packagedata_free(&packagedata);
 			return r;
 		}
 		if (strcmp(source, pkg->sourcename) != 0) {
@@ -1277,7 +1279,7 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 			free(source);
 			free(version);
 			free(package);
-			free(control);
+			packagedata_free(&packagedata);
 			continue;
 		}
 		free(source);
@@ -1293,15 +1295,15 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 			}
 			free(package);
 			free(version);
-			free(control);
+			packagedata_free(&packagedata);
 			continue;
 		}
 		free(version);
-		r = target->getfilekeys(control, &filekeys);
+		r = target->getfilekeys(packagedata.chunk, &filekeys);
 		assert (r != RET_NOTHING);
 		if (RET_WAS_ERROR(r)) {
 			free(package);
-			free(control);
+			packagedata_free(&packagedata);
 			return r;
 		}
 
@@ -1313,9 +1315,9 @@ static retvalue targetremovesourcepackage(trackingdb t, struct trackedpackage *p
 		/* that is a bit wasteful, as it parses some stuff again, but
 		 * but that is better than reimplementing logger here */
 		r = target_removereadpackage(target, distribution->logger,
-				package, control, NULL);
+				package, &packagedata, NULL);
 		target->staletracking = savedstaletracking;
-		free(control);
+		packagedata_free(&packagedata);
 		free(package);
 		assert (r != RET_NOTHING);
 		if (RET_WAS_ERROR(r)) {
@@ -1392,10 +1394,10 @@ retvalue tracking_removepackages(trackingdb t, struct distribution *distribution
 	return result;
 }
 
-static retvalue package_retrack(UNUSED(struct distribution *di), struct target *target, const char *packagename, const char *controlchunk, void *data) {
+static retvalue package_retrack(UNUSED(struct distribution *di), struct target *target, const char *packagename, const struct packagedata *packagedata, void *data) {
 	trackingdb tracks = data;
 
-	return target->doretrack(packagename, controlchunk, tracks);
+	return target->doretrack(packagename, packagedata->chunk, tracks);
 }
 
 retvalue tracking_retrack(struct distribution *d, bool needsretrack) {
diff --git a/upgradelist.c b/upgradelist.c
index 93bc69a..272b46c 100644
--- a/upgradelist.c
+++ b/upgradelist.c
@@ -142,7 +142,8 @@ static retvalue save_package_version(struct upgradelist *upgrade, const char *pa
 retvalue upgradelist_initialize(struct upgradelist **ul, struct target *t) {
 	struct upgradelist *upgrade;
 	retvalue r, r2;
-	const char *packagename, *controlchunk;
+	const char *packagename;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	upgrade = zNEW(struct upgradelist);
@@ -158,8 +159,8 @@ retvalue upgradelist_initialize(struct upgradelist **ul, struct target *t) {
 		upgradelist_free(upgrade);
 		return r;
 	}
-	while (target_nextpackage(&iterator, &packagename, &controlchunk)) {
-		r2 = save_package_version(upgrade, packagename, controlchunk);
+	while (target_nextpackage(&iterator, &packagename, &packagedata)) {
+		r2 = save_package_version(upgrade, packagename, packagedata.chunk);
 		RET_UPDATE(r, r2);
 		if (RET_WAS_ERROR(r2))
 			break;
@@ -538,7 +539,8 @@ retvalue upgradelist_update(struct upgradelist *upgrade, void *privdata, const c
 
 retvalue upgradelist_pull(struct upgradelist *upgrade, struct target *source, upgrade_decide_function *predecide, void *decide_data, void *privdata) {
 	retvalue result, r;
-	const char *package, *control;
+	const char *package;
+	struct packagedata packagedata;
 	struct target_cursor iterator;
 
 	upgrade->last = NULL;
@@ -546,20 +548,20 @@ retvalue upgradelist_pull(struct upgradelist *upgrade, struct target *source, up
 	if (RET_WAS_ERROR(r))
 		return r;
 	result = RET_NOTHING;
-	while (target_nextpackage(&iterator, &package, &control)) {
+	while (target_nextpackage(&iterator, &package, &packagedata)) {
 		char *version;
 		architecture_t package_architecture;
 		char *sourcename, *sourceversion;
 
 		assert (source->packagetype == upgrade->target->packagetype);
 
-		r = source->getversion(control, &version);
+		r = source->getversion(packagedata.chunk, &version);
 		assert (r != RET_NOTHING);
 		if (!RET_IS_OK(r)) {
 			RET_UPDATE(result, r);
 			break;
 		}
-		r = source->getarchitecture(control, &package_architecture);
+		r = source->getarchitecture(packagedata.chunk, &package_architecture);
 		if (!RET_IS_OK(r)) {
 			RET_UPDATE(result, r);
 			break;
@@ -590,14 +592,14 @@ retvalue upgradelist_pull(struct upgradelist *upgrade, struct target *source, up
 			continue;
 		}
 
-		r = upgrade->target->getsourceandversion(control, package,
+		r = upgrade->target->getsourceandversion(packagedata.chunk, package,
 				&sourcename, &sourceversion);
 		if (RET_IS_OK(r)) {
 			r = upgradelist_trypackage(upgrade, privdata,
 					predecide, decide_data,
 					package, NULL, sourcename,
 					version, sourceversion,
-					package_architecture, control);
+					package_architecture, packagedata.chunk);
 			RET_UPDATE(result, r);
 			free(sourcename);
 			free(sourceversion);
@@ -661,7 +663,7 @@ retvalue upgradelist_predelete(struct upgradelist *upgrade, struct logger *logge
 				r = RET_ERROR_INTERRUPTED;
 			else
 				r = target_removepackage(upgrade->target,
-						logger, pkg->name, NULL);
+						logger, pkg->name, pkg->version, NULL);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
@@ -766,7 +768,7 @@ retvalue upgradelist_install(struct upgradelist *upgrade, struct logger *logger,
 				r = RET_ERROR_INTERRUPTED;
 			else
 				r = target_removepackage(upgrade->target,
-						logger, pkg->name, NULL);
+						logger, pkg->name, pkg->version, NULL);
 			RET_UPDATE(result, r);
 			if (RET_WAS_ERROR(r))
 				break;
-- 
1.9.1

